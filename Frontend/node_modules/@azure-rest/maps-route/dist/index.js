'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var coreAuth = require('@azure/core-auth');
var mapsCommon = require('@azure/maps-common');
var coreClient = require('@azure-rest/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreLro = require('@azure/core-lro');

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Initialize a new instance of the class MapsRouteClient class.
 * @param credentials type: KeyCredential
 */
function createClient(credentials, options = {}) {
    const baseUrl = options.baseUrl ?? `https://atlas.microsoft.com`;
    options.apiVersion = options.apiVersion ?? "1.0";
    options = {
        ...options,
        credentials: {
            apiKeyHeaderName: "subscription-key"
        }
    };
    const userAgentInfo = `azsdk-js-maps-route-rest/1.0.0-beta.1`;
    const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
        ? `${options.userAgentOptions.userAgentPrefix} ${userAgentInfo}`
        : `${userAgentInfo}`;
    options = {
        ...options,
        userAgentOptions: {
            userAgentPrefix
        }
    };
    const client = coreClient.getClient(baseUrl, credentials, options);
    return client;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const responseMap = {
    "POST /route/matrix/{format}": ["200", "202"],
    "GET /route/matrix/{format}": ["200", "202"],
    "POST /route/matrix/sync/{format}": ["200"],
    "GET /route/directions/{format}": ["200"],
    "POST /route/directions/{format}": ["200"],
    "GET /route/range/{format}": ["200"],
    "POST /route/directions/batch/{format}": ["200", "202"],
    "GET /route/directions/batch/{format}": ["200", "202"],
    "POST /route/directions/batch/sync/{format}": ["200"]
};
function isUnexpected(response) {
    const lroOriginal = response.headers["x-ms-original-url"];
    const url = new URL(lroOriginal ?? response.request.url);
    const method = response.request.method;
    let pathDetails = responseMap[`${method} ${url.pathname}`];
    if (!pathDetails) {
        pathDetails = geParametrizedPathSuccess(method, url.pathname);
    }
    return !pathDetails.includes(response.status);
}
function geParametrizedPathSuccess(method, path) {
    const pathParts = path.split("/");
    // Iterate the responseMap to find a match
    for (const [key, value] of Object.entries(responseMap)) {
        // Extracting the path from the map key which is in format
        // GET /path/foo
        if (!key.startsWith(method)) {
            continue;
        }
        const candidatePath = getPathFromMapKey(key);
        // Get each part of the url path
        const candidateParts = candidatePath.split("/");
        // If the candidate and actual paths don't match in size
        // we move on to the next candidate path
        if (candidateParts.length === pathParts.length &&
            hasParametrizedPath(key)) {
            // track if we have found a match to return the values found.
            let found = true;
            for (let i = 0; i < candidateParts.length; i++) {
                if (candidateParts[i]?.startsWith("{") &&
                    candidateParts[i]?.endsWith("}")) {
                    // If the current part of the candidate is a "template" part
                    // it is a match with the actual path part on hand
                    // skip as the parameterized part can match anything
                    continue;
                }
                // If the candidate part is not a template and
                // the parts don't match mark the candidate as not found
                // to move on with the next candidate path.
                if (candidateParts[i] !== pathParts[i]) {
                    found = false;
                    break;
                }
            }
            // We finished evaluating the current candidate parts
            // if all parts matched we return the success values form
            // the path mapping.
            if (found) {
                return value;
            }
        }
    }
    // No match was found, return an empty array.
    return [];
}
function hasParametrizedPath(path) {
    return path.includes("/{");
}
function getPathFromMapKey(mapKey) {
    const pathStart = mapKey.indexOf("/");
    return mapKey.slice(pathStart);
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Helper function that builds a Poller object to help polling a long running operation.
 * @param client - Client to use for sending the request to get additional pages.
 * @param initialResponse - The initial response.
 * @param options - Options to set a resume state or custom polling interval.
 * @returns - A poller object to poll for operation state updates and eventually get the final response.
 */
function getLongRunningPoller(client, initialResponse, options = {}) {
    const poller = {
        requestMethod: initialResponse.request.method,
        requestPath: initialResponse.request.url,
        sendInitialRequest: async () => {
            // In the case of Rest Clients we are building the LRO poller object from a response that's the reason
            // we are not triggering the initial request here, just extracting the information from the
            // response we were provided.
            return getLroResponse(initialResponse);
        },
        sendPollRequest: async (path) => {
            // This is the callback that is going to be called to poll the service
            // to get the latest status. We use the client provided and the polling path
            // which is an opaque URL provided by caller, the service sends this in one of the following headers: operation-location, azure-asyncoperation or location
            // depending on the lro pattern that the service implements. If non is provided we default to the initial path.
            const response = await client
                .pathUnchecked(path ?? initialResponse.request.url)
                .get();
            const lroResponse = getLroResponse(response);
            lroResponse.rawResponse.headers["x-ms-original-url"] =
                initialResponse.request.url;
            return lroResponse;
        }
    };
    return new coreLro.LroEngine(poller, options);
}
/**
 * Converts a Rest Client response to a response that the LRO engine knows about
 * @param response - a rest client http response
 * @returns - An LRO response that the LRO engine can work with
 */
function getLroResponse(response) {
    if (Number.isNaN(response.status)) {
        throw new TypeError(`Status code of the response is not a number. Value: ${response.status}`);
    }
    return {
        flatResponse: response,
        rawResponse: {
            ...response,
            statusCode: Number.parseInt(response.status),
            body: response.body
        }
    };
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function MapsRoute(credential, clientIdOrOptions = {}, maybeOptions = {}) {
    const options = typeof clientIdOrOptions === "string" ? maybeOptions : clientIdOrOptions;
    /**
     * maps service requires a header "ms-x-client-id", which is different from the standard AAD.
     * So we need to do our own implementation.
     * This customized authentication is following by this guide: https://github.com/Azure/azure-sdk-for-js/blob/main/documentation/RLC-customization.md#custom-authentication
     */
    if (coreAuth.isTokenCredential(credential)) {
        const clientId = typeof clientIdOrOptions === "string" ? clientIdOrOptions : "";
        if (!clientId) {
            throw Error("Client id is needed for TokenCredential");
        }
        const client = createClient(undefined, options);
        client.pipeline.addPolicy(coreRestPipeline.bearerTokenAuthenticationPolicy({
            credential,
            scopes: `${options.baseUrl || "https://atlas.microsoft.com"}/.default`,
        }));
        client.pipeline.addPolicy(mapsCommon.createMapsClientIdPolicy(clientId));
        return client;
    }
    if (coreAuth.isSASCredential(credential)) {
        const client = createClient(undefined, options);
        client.pipeline.addPolicy({
            name: "mapsSASCredentialPolicy",
            async sendRequest(request, next) {
                request.headers.set("Authorization", `jwt-sas ${credential.signature}`);
                return next(request);
            },
        });
        return client;
    }
    return createClient(credential, options);
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function toLatLonString(coordinates) {
    return `${coordinates[0]},${coordinates[1]}`;
}
/**
 * Transform an array of [Latitude, Longtitute] to a string in the following format:
 * "Latitude_1,Longtitute_1:Latitude_2,Longtitute_2:..."
 *
 * @param coordinates - An array of Latitude/Longtitute pair to transform.
 * @returns The transformed string.
 */
function toColonDelimitedLatLonString(coordinates) {
    return coordinates.map((c) => toLatLonString(c)).join(":");
}
/**
 * Create a batch request body of a bunch of route direction requests.
 *
 * @param queryParamProperties - An object of the query parameters for a route direction request
 * @returns The composed batch request.
 */
function createRouteDirectionsBatchRequest(queryParamProperties) {
    return {
        batchItems: queryParamProperties.map((queryParam) => ({
            query: "?" +
                Object.entries(queryParam)
                    .map(([k, v]) => {
                    // Skip if no value
                    if (typeof v === "undefined" || v === null) {
                        return "";
                    }
                    // Check name mappings: Array values
                    if ((k === "departAt" || k === "arriveAt") && v instanceof Date) {
                        return `${k}=${v.toISOString()}`;
                    }
                    return `${k}=${v}`;
                })
                    .filter((s) => s !== "")
                    .join("&"),
        })),
    };
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

exports.createRouteDirectionsBatchRequest = createRouteDirectionsBatchRequest;
exports.default = MapsRoute;
exports.getLongRunningPoller = getLongRunningPoller;
exports.isUnexpected = isUnexpected;
exports.toColonDelimitedLatLonString = toColonDelimitedLatLonString;
//# sourceMappingURL=index.js.map
