import { KeyCredential } from '@azure/core-auth';
import { LroResponse } from '@azure/core-lro';
import { OperationOptions } from '@azure/core-client';
import { OperationSpec } from '@azure/core-client';
import { PipelinePolicy } from '@azure/core-rest-pipeline';
import { ServiceClient } from '@azure/core-client';

/** Bounding box including information on the coordinate range for its geometries */
export declare type BBox = BBox2D | BBox3D;

/** 2D bounding box */
export declare type BBox2D = [
southWestLongitude: number,
southWestLatitude: number,
northEastLongitude: number,
northEastLatitude: number
];

/** 3D bounding box */
export declare type BBox3D = [
southWestLongitude: number,
southWestLatitude: number,
southWestElevation: number,
northEastLongitude: number,
northEastLatitude: number,
northEastElevation: number
];

/**
 * Bounding Box
 */
export declare interface BoundingBox {
    /** Top left corner of the bounding box */
    topLeft: LatLon;
    /** Bottom right corner of the bounding box */
    bottomRight: LatLon;
}

/**
 * Create an HTTP pipeline policy to authenticate a request
 * using an `AzureKeyCredential` for Azure Maps
 */
export declare function createAzureMapsKeyCredentialPolicy(azureKeyCredential: KeyCredential): PipelinePolicy;

/**
 * Create an HTTP pipeline policy to add x-ms-client-id header
 * for `TokenCredential` based authentication for Azure Maps
 */
export declare function createMapsClientIdPolicy(mapsClientId: string): PipelinePolicy;

/**
 * Helper function to create a method that can be passed to sendPollRequest in createHttpPoller.
 *
 * @param settings - The settings of the poll request, including client, options and the spec
 * @returns A callback that accept the path as input and return the promise of Lro response.
 */
export declare function createSendPollRequest<TOptions extends OperationOptions, TClient extends ServiceClient>(settings: {
    client: TClient;
    options: TOptions;
    spec: OperationSpec;
}): (path: string) => Promise<LroResponse<unknown>>;

/**
 * GeoJSON Feature
 * A Feature object represents a spatially bounded thing.  Every Feature
 object is a GeoJSON object. [Reference](https://www.rfc-editor.org/rfc/rfc7946#section-3.2)
 */
export declare interface GeoJsonFeature extends GeoJsonObject {
    type: "Feature";
    geometry?: GeoJsonGeometry;
    properties?: Record<string, any>;
    id?: number | string;
}

/** GeoJSON FeatureCollection. [Reference](https://www.rfc-editor.org/rfc/rfc7946#section-3.3) */
export declare interface GeoJsonFeatureCollection extends GeoJsonObject {
    type: "FeatureCollection";
    features: GeoJsonFeature[];
}

/** GeoJSON Geometry */
export declare type GeoJsonGeometry = GeoJsonPoint | GeoJsonMultiPoint | GeoJsonLineString | GeoJsonMultiLineString | GeoJsonPolygon | GeoJsonMultiPolygon;

/** GeoJSON GeometryCollection. [Reference](https://www.rfc-editor.org/rfc/rfc7946#section-3.1.8) */
export declare interface GeoJsonGeometryCollection extends GeoJsonObject {
    type: "GeometryCollection";
    geometries: GeoJsonGeometry[];
}

/** GeoJSON LineString. [Reference](https://www.rfc-editor.org/rfc/rfc7946#section-3.1.4) */
export declare interface GeoJsonLineString extends GeoJsonObject {
    type: "LineString";
    /** For type "LineString", the "coordinates" member is an array of two or more positions. */
    coordinates: Position[];
}

/** GeoJSON MultiLineString. [Reference](https://www.rfc-editor.org/rfc/rfc7946#section-3.1.5) */
export declare interface GeoJsonMultiLineString extends GeoJsonObject {
    type: "MultiLineString";
    /** For type "MultiLineString", the "coordinates" member is an array of LineString coordinate arrays. */
    coordinates: Position[][];
}

/** GeoJSON MultiPoint. [Reference](https://www.rfc-editor.org/rfc/rfc7946#section-3.1.3) */
export declare interface GeoJsonMultiPoint extends GeoJsonObject {
    type: "MultiPoint";
    /** For type "MultiPoint", the "coordinates" member is an array of positions. */
    coordinates: Position[];
}

/** GeoJSON MultiPolygon. [Reference](https://www.rfc-editor.org/rfc/rfc7946#section-3.1.7) */
export declare interface GeoJsonMultiPolygon extends GeoJsonObject {
    type: "MultiPolygon";
    /** For type "MultiPolygon", the "coordinates" member is an array of Polygon coordinate arrays. */
    coordinates: Position[][][];
}

/** A GeoJSON object represents a Geometry, Feature, or collection of
 Features. [Reference](https://www.rfc-editor.org/rfc/rfc7946#section-3) */
export declare interface GeoJsonObject {
    /** Representing the type of this GeoJSON object, including the seven geometry type and "Feature", "FeatureCollection". [Reference](https://www.rfc-editor.org/rfc/rfc7946#section-1.4) */
    type: GeoJsonType;
    /** Include information on the coordinate range for its Geometries, Features, or FeatureCollections. [Reference](https://www.rfc-editor.org/rfc/rfc7946#section-5) */
    bbox?: BBox;
}

/** GeoJSON Point. [Reference](https://www.rfc-editor.org/rfc/rfc7946#section-3.1.2) */
export declare interface GeoJsonPoint extends GeoJsonObject {
    type: "Point";
    /** For type "Point", the "coordinates" member is a single position. */
    coordinates: Position;
}

/**
 * GeoJSON Polygon. [Reference](https://www.rfc-editor.org/rfc/rfc7946#section-3.1.6)
 *
 * To specify a constraint specific to Polygons, it is useful to introduce the concept of a linear ring:
 *  - A linear ring is a closed LineString with four or more positions.
 *  - The first and last positions are equivalent, and they MUST contain identical values; their representation SHOULD also be identical.
 *  - A linear ring is the boundary of a surface or the boundary of a hole in a surface.
 *  - A linear ring MUST follow the right-hand rule with respect to the area it bounds, i.e., exterior rings are counterclockwise, and holes are clockwise.
 * */
export declare interface GeoJsonPolygon extends GeoJsonObject {
    type: "Polygon";
    /** For type "Polygon", the "coordinates" member MUST be an array of linear ring coordinate arrays. */
    coordinates: Position[][];
}

/** GeoJSON types */
export declare type GeoJsonType = GeometryType | "Feature" | "FeatureCollection";

/** Geometry types */
export declare type GeometryType = "Point" | "MultiPoint" | "LineString" | "MultiLineString" | "Polygon" | "MultiPolygon" | "GeometryCollection";

/**
 * Extract several fields of the response to the rawResponse
 *
 * @param getResponse - A async function that actually call the backend API.
 * @param options - The options for the getResponse callback
 * @returns A promise for the API call.
 */
export declare function getRawResponse<TOptions extends OperationOptions, TResponse>(getResponse: (options: TOptions) => Promise<TResponse>, options: TOptions): Promise<LroResponse<TResponse>>;

/**
 * Latitude/Longitude Pair
 */
export declare type LatLon = [latitude: number, longitude: number];

/** An array of number representing a point */
export declare type Position = Position2D | Position3D;

/** 2D position */
export declare type Position2D = [longitude: number, latitude: number];

/** 3D position */
export declare type Position3D = [longitude: number, latitude: number, elevation: number];

export { }
