import { AzureKeyCredential } from '@azure/core-auth';
import { AzureSASCredential } from '@azure/core-auth';
import { Client } from '@azure-rest/core-client';
import { ClientOptions } from '@azure-rest/core-client';
import { HttpResponse } from '@azure-rest/core-client';
import { LatLon } from '@azure/maps-common';
import { LroEngineOptions } from '@azure/core-lro';
import { PollerLike } from '@azure/core-lro';
import { PollOperationState } from '@azure/core-lro';
import { RawHttpHeaders } from '@azure/core-rest-pipeline';
import { RequestParameters } from '@azure-rest/core-client';
import { StreamableMethod } from '@azure-rest/core-client';
import { TokenCredential } from '@azure/core-auth';

/** This type represents the request body for the Batch service. */
export declare interface BatchRequest {
    /** The list of queries to process. */
    batchItems?: Array<BatchRequestItem>;
}

/** Batch request object */
export declare interface BatchRequestItem {
    /** This parameter contains a query string used to perform an unstructured geocoding operation. The query string will be passed verbatim to the search API for processing. */
    query?: string;
}

/** An item returned from Batch API. Extend with 'response' property. */
export declare interface BatchResultItemOutput {
    /** HTTP request status code. */
    statusCode: number;
}

/** This object is returned from a successful Batch service call. Extend with 'batchItems' property. */
export declare interface BatchResultOutput {
    /** Summary of the results for the batch request */
    summary: BatchResultSummaryOutput;
}

/** Summary of the results for the batch request */
export declare interface BatchResultSummaryOutput {
    /** Number of successful requests in the batch */
    successfulRequests: number;
    /** Total number of requests in the batch */
    totalRequests: number;
}

/**
 * Create a batch request body of a bunch of route direction requests.
 *
 * @param queryParamProperties - An object of the query parameters for a route direction request
 * @returns The composed batch request.
 */
export declare function createRouteDirectionsBatchRequest(queryParamProperties: RouteGetRouteDirectionsQueryParamProperties[]): BatchRequest;

/** Effective parameter or data used when calling this Route API. */
export declare interface EffectiveSettingOutput {
    /** Name of the parameter used. */
    key: string;
    /** Value of the parameter used. */
    value: string;
}

/** The error detail. */
export declare interface ErrorDetailOutput {
    /** The error code. */
    code?: string;
    /** The error message. */
    message?: string;
}

/** Common error response for all Azure Resource Manager APIs to return error details for failed operations. (This also follows the OData error response format.). */
export declare interface ErrorResponseOutput {
    /** The error object. */
    error?: ErrorDetailOutput;
}

/** A valid `GeoJSON Feature` object type. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.2) for details. */
export declare interface GeoJsonFeature extends GeoJsonObjectParent, GeoJsonFeatureData {
    type: "Feature";
}

/** A valid `GeoJSON FeatureCollection` object type. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.3) for details. */
export declare interface GeoJsonFeatureCollection extends GeoJsonObjectParent, GeoJsonFeatureCollectionData {
    type: "FeatureCollection";
}

export declare interface GeoJsonFeatureCollectionData {
    /** Contains a list of valid `GeoJSON Feature` objects. */
    features: Array<GeoJsonFeature>;
}

export declare interface GeoJsonFeatureData {
    /** A valid `GeoJSON` geometry object. The type must be one of the seven valid GeoJSON geometry types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon and GeometryCollection. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1) for details. */
    geometry: GeoJsonGeometry;
    /** Properties can contain any additional metadata about the `Feature`. Value can be any JSON object or a JSON null value */
    properties?: Record<string, unknown>;
    /** Identifier for the feature. */
    id?: string;
    /** The type of the feature. The value depends on the data model the current feature is part of. Some data models may have an empty value. */
    featureType?: string;
}

/** A valid `GeoJSON` geometry object. The type must be one of the seven valid GeoJSON geometry types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon and GeometryCollection. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1) for details. */
export declare type GeoJsonGeometry = GeoJsonGeometryParent | GeoJsonMultiPoint | GeoJsonMultiPolygon | GeoJsonPoint | GeoJsonLineString | GeoJsonMultiLineString | GeoJsonPolygon | GeoJsonGeometryCollection;

/** A valid `GeoJSON GeometryCollection` object type. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1.8) for details. */
export declare interface GeoJsonGeometryCollection extends GeoJsonGeometryParent, GeoJsonGeometryCollectionData {
    type: "GeometryCollection";
}

export declare interface GeoJsonGeometryCollectionData {
    /** Contains a list of valid `GeoJSON` geometry objects. **Note** that coordinates in GeoJSON are in x, y order (longitude, latitude). */
    geometries: Array<GeoJsonGeometry>;
}

/** A valid `GeoJSON` geometry object. The type must be one of the seven valid GeoJSON geometry types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon and GeometryCollection. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1) for details. */
export declare interface GeoJsonGeometryParent extends GeoJsonObjectParent {
    type: "GeoJsonGeometry" | "MultiPoint" | "MultiPolygon" | "Point" | "LineString" | "MultiLineString" | "Polygon" | "GeometryCollection";
}

/** A valid `GeoJSON LineString` geometry type. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1.4) for details. */
export declare interface GeoJsonLineString extends GeoJsonGeometryParent, GeoJsonLineStringData {
    type: "LineString";
}

export declare interface GeoJsonLineStringData {
    /** Coordinates for the `GeoJson LineString` geometry. */
    coordinates: Array<Array<number>>;
}

/** A valid `GeoJSON MultiLineString` geometry type. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1.5) for details. */
export declare interface GeoJsonMultiLineString extends GeoJsonGeometryParent, GeoJsonMultiLineStringData {
    type: "MultiLineString";
}

export declare interface GeoJsonMultiLineStringData {
    /** Coordinates for the `GeoJson MultiLineString` geometry. */
    coordinates: Array<Array<Array<number>>>;
}

/** A valid `GeoJSON MultiPoint` geometry type. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1.3) for details. */
export declare interface GeoJsonMultiPoint extends GeoJsonGeometryParent, GeoJsonMultiPointData {
    type: "MultiPoint";
}

/** Data contained by a `GeoJson MultiPoint`. */
export declare interface GeoJsonMultiPointData {
    /** Coordinates for the `GeoJson MultiPoint` geometry. */
    coordinates: Array<Array<number>>;
}

/** A valid `GeoJSON MultiPolygon` object type. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1.7) for details. */
export declare interface GeoJsonMultiPolygon extends GeoJsonGeometryParent, GeoJsonMultiPolygonData {
    type: "MultiPolygon";
}

export declare interface GeoJsonMultiPolygonData {
    /** Contains a list of valid `GeoJSON Polygon` objects. **Note** that coordinates in GeoJSON are in x, y order (longitude, latitude). */
    coordinates: Array<Array<Array<Array<number>>>>;
}

/** A valid `GeoJSON` object. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3) for details. */
export declare type GeoJsonObject = GeoJsonGeometry | GeoJsonMultiPoint | GeoJsonMultiPolygon | GeoJsonPoint | GeoJsonLineString | GeoJsonMultiLineString | GeoJsonPolygon | GeoJsonGeometryCollection | GeoJsonFeature | GeoJsonFeatureCollection;

/** A valid `GeoJSON` object. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3) for details. */
export declare interface GeoJsonObjectParent {
    type: "GeoJsonObject" | "GeoJsonGeometry" | "MultiPoint" | "MultiPolygon" | "Point" | "LineString" | "MultiLineString" | "Polygon" | "GeometryCollection" | "Feature" | "FeatureCollection";
}

/** A valid `GeoJSON Point` geometry type. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1.2) for details. */
export declare interface GeoJsonPoint extends GeoJsonGeometryParent, GeoJsonPointData {
    type: "Point";
}

/** Data contained by a `GeoJson Point`. */
export declare interface GeoJsonPointData {
    /** A `Position` is an array of numbers with two or more elements. The first two elements are _longitude_ and _latitude_, precisely in that order. _Altitude/Elevation_ is an optional third element. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1.1) for details. */
    coordinates: Array<number>;
}

/** A valid `GeoJSON Polygon` geometry type. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1.6) for details. */
export declare interface GeoJsonPolygon extends GeoJsonGeometryParent, GeoJsonPolygonData {
    type: "Polygon";
}

export declare interface GeoJsonPolygonData {
    /** Coordinates for the `GeoJson Polygon` geometry type. */
    coordinates: Array<Array<Array<number>>>;
}

/**
 * Helper function that builds a Poller object to help polling a long running operation.
 * @param client - Client to use for sending the request to get additional pages.
 * @param initialResponse - The initial response.
 * @param options - Options to set a resume state or custom polling interval.
 * @returns - A poller object to poll for operation state updates and eventually get the final response.
 */
export declare function getLongRunningPoller<TResult extends HttpResponse>(client: Client, initialResponse: TResult, options?: LroEngineOptions<TResult, PollOperationState<TResult>>): PollerLike<PollOperationState<TResult>, TResult>;

export declare interface GetRouteDirections {
    /**
     * **Applies to**: see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     *
     * Returns  a route between an origin and a destination, passing through waypoints if they are specified. The route will take into account factors such as current traffic and the typical road speeds on the requested day of the week and time of day.
     *
     * Information returned includes the distance, estimated travel time, and a representation of the route geometry. Additional routing information such as optimized waypoint order or turn by turn instructions is also available, depending on the options selected.
     *
     * Routing service provides a set of parameters for a detailed description of vehicle-specific Consumption Model. Please check [Consumption Model](https://docs.microsoft.com/azure/azure-maps/consumption-model) for detailed explanation of the concepts and parameters involved.
     */
    get(options: RouteGetRouteDirectionsParameters): StreamableMethod<RouteGetRouteDirections200Response | RouteGetRouteDirectionsDefaultResponse>;
    /**
     * **Applies to**: see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     *
     * Returns  a route between an origin and a destination, passing through waypoints if they are specified. The route will take into account factors such as current traffic and the typical road speeds on the requested day of the week and time of day.
     *
     * Information returned includes the distance, estimated travel time, and a representation of the route geometry. Additional routing information such as optimized waypoint order or turn by turn instructions is also available, depending on the options selected.
     *
     * Routing service provides a set of parameters for a detailed description of a vehicle-specific Consumption Model. Please check [Consumption Model](https://docs.microsoft.com/azure/azure-maps/consumption-model) for detailed explanation of the concepts and parameters involved.
     */
    post(options: RouteGetRouteDirectionsWithAdditionalParametersParameters): StreamableMethod<RouteGetRouteDirectionsWithAdditionalParameters200Response | RouteGetRouteDirectionsWithAdditionalParametersDefaultResponse>;
}

export declare interface GetRouteRange {
    /**
     * __Route Range (Isochrone) API__
     *
     *
     * **Applies to**: see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * This service will calculate a set of locations that can be reached from the origin point based on fuel, energy,  time or distance budget that is specified. A polygon boundary (or Isochrone) is returned in a counterclockwise  orientation as well as the precise polygon center which was the result of the origin point.
     *
     * The returned polygon can be used for further processing such as  [Search Inside Geometry](https://docs.microsoft.com/rest/api/maps/search/postsearchinsidegeometry) to  search for POIs within the provided Isochrone.
     */
    get(options: RouteGetRouteRangeParameters): StreamableMethod<RouteGetRouteRange200Response | RouteGetRouteRangeDefaultResponse>;
}

export declare function isUnexpected(response: RouteRequestRouteMatrixSync200Response | RouteRequestRouteMatrixSync408Response | RouteRequestRouteMatrixSyncDefaultResponse): response is RouteRequestRouteMatrixSync408Response;

export declare function isUnexpected(response: RouteGetRouteDirections200Response | RouteGetRouteDirectionsDefaultResponse): response is RouteGetRouteDirectionsDefaultResponse;

export declare function isUnexpected(response: RouteGetRouteDirectionsWithAdditionalParameters200Response | RouteGetRouteDirectionsWithAdditionalParametersDefaultResponse): response is RouteGetRouteDirectionsWithAdditionalParametersDefaultResponse;

export declare function isUnexpected(response: RouteGetRouteRange200Response | RouteGetRouteRangeDefaultResponse): response is RouteGetRouteRangeDefaultResponse;

export declare function isUnexpected(response: RouteRequestRouteDirectionsBatchSync200Response | RouteRequestRouteDirectionsBatchSync408Response | RouteRequestRouteDirectionsBatchSyncDefaultResponse): response is RouteRequestRouteDirectionsBatchSync408Response;

/** A location represented as a latitude and longitude. */
export declare interface LatLongPairOutput {
    /** Latitude property */
    latitude: number;
    /** Longitude property */
    longitude: number;
}

/**
 * Creates an instance of MapsRouteClient from a subscription key.
 *
 * @example
 * ```ts
 * import MapsRoute from "@azure-rest/maps-route";
 * import { AzureKeyCredential } from "@azure/core-auth";
 *
 * const credential = new AzureKeyCredential("<subscription-key>");
 * const client = MapsRoute(credential);
 *```
 *
 * @param credential - An AzureKeyCredential instance used to authenticate requests to the service
 * @param options - Options used to configure the Route Client
 */
declare function MapsRoute(credential: AzureKeyCredential, options?: ClientOptions): MapsRouteClient;

/**
 * Creates an instance of MapsRoute from an Azure Identity `TokenCredential`.
 *
 * @example
 * ```ts
 * import MapsRoute from "@azure-rest/maps-route";
 * import { DefaultAzureCredential } from "@azure/identity";
 *
 * const credential = new DefaultAzureCredential();
 * const client = MapsRoute(credential, "<maps-account-client-id>");
 *```
 *
 * @param credential - An TokenCredential instance used to authenticate requests to the service
 * @param mapsAccountClientId - The Azure Maps client id of a specific map resource
 * @param options - Options used to configure the Route Client
 */
declare function MapsRoute(credential: TokenCredential, mapsAccountClientId: string, options?: ClientOptions): MapsRouteClient;

/**
 * Creates an instance of MapsRoute from an Azure Identity `AzureSASCredential`.
 *
 * @example
 * ```ts
 * import MapsRoute from "@azure-rest/maps-route";
 * import { AzureSASCredential } from "@azure/core-auth";
 *
 * const credential = new AzureSASCredential("<SAS Token>");
 * const client = MapsRoute(credential);
 * ```
 *
 * @param credential - An AzureSASCredential instance used to authenticate requests to the service
 * @param options - Options used to configure the Route Client
 */
declare function MapsRoute(credential: AzureSASCredential, options?: ClientOptions): MapsRouteClient;
export default MapsRoute;

export declare type MapsRouteClient = Client & {
    path: Routes;
};

export declare interface RequestRouteDirectionsBatch {
    /**
     * **Route Directions Batch API**
     *
     *
     * **Applies to**: see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     *
     *
     * The Route Directions Batch API sends batches of queries to [Route Directions API](https://docs.microsoft.com/rest/api/maps/route/getroutedirections) using just a single API call. You can call Route Directions Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to **700** queries and sync API up to **100** queries.
     * ### Submit Asynchronous Batch Request
     * The Asynchronous API is appropriate for processing big volumes of relatively complex route requests
     * - It allows the retrieval of results in a separate call (multiple downloads are possible).
     * - The asynchronous API is optimized for reliability and is not expected to run into a timeout.
     * - The number of batch items is limited to **700** for this API.
     *
     * When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the response header. This URL should be checked periodically until the response data or error information is available.
     * The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the expiration period.
     *
     * Please note that asynchronous batch request is a long-running request. Here's a typical sequence of operations:
     * 1. Client sends a Route Directions Batch `POST` request to Azure Maps
     * 2. The server will respond with one of the following:
     *
     *     > HTTP `202 Accepted` - Batch request has been accepted.
     *
     *     > HTTP `Error` - There was an error processing your Batch request. This could either be a `400 Bad Request` or any other `Error` status code.
     *
     * 3. If the batch request was accepted successfully, the `Location` header in the response contains the URL to download the results of the batch request.
     *     This status URI looks like following:
     *
     * ``` GET https://atlas.microsoft.com/route/directions/batch/{batch-id}?api-version=1.0 ```
     * Note:- Please remember to add AUTH information (subscription-key/azure_auth - See [Security](#security)) to the _status URI_ before running it. <br>
     * 4. Client issues a `GET` request on the _download URL_ obtained in Step 3 to download the batch results.
     *
     * ### POST Body for Batch Request
     * To send the _route directions_ queries you will use a `POST` request where the request body will contain the `batchItems` array in `json` format and the `Content-Type` header will be set to `application/json`. Here's a sample request body containing 3 _route directions_ queries:
     *
     *
     * ```json
     * {
     *     "batchItems": [
     *         { "query": "?query=47.620659,-122.348934:47.610101,-122.342015&travelMode=bicycle&routeType=eco&traffic=false" },
     *         { "query": "?query=40.759856,-73.985108:40.771136,-73.973506&travelMode=pedestrian&routeType=shortest" },
     *         { "query": "?query=48.923159,-122.557362:32.621279,-116.840362" }
     *     ]
     * }
     * ```
     *
     * A _route directions_ query in a batch is just a partial URL _without_ the protocol, base URL, path, api-version and subscription-key. It can accept any of the supported _route directions_ [URI parameters](https://docs.microsoft.com/rest/api/maps/route/getroutedirections#uri-parameters). The string values in the _route directions_ query must be properly escaped (e.g. " character should be escaped with \\ ) and it should also be properly URL-encoded.
     *
     *
     * The async API allows caller to batch up to **700** queries and sync API up to **100** queries, and the batch should contain at least **1** query.
     *
     *
     * ### Download Asynchronous Batch Results
     * To download the async batch results you will issue a `GET` request to the batch download endpoint. This _download URL_ can be obtained from the `Location` header of a successful `POST` batch request and looks like the following:
     *
     * ```
     * https://atlas.microsoft.com/route/directions/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
     * ```
     * Here's the typical sequence of operations for downloading the batch results:
     * 1. Client sends a `GET` request using the _download URL_.
     * 2. The server will respond with one of the following:
     *
     *     > HTTP `202 Accepted` - Batch request was accepted but is still being processed. Please try again in some time.
     *
     *     > HTTP `200 OK` - Batch request successfully processed. The response body contains all the batch results.
     *
     *
     *
     * ### Batch Response Model
     * The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the batch has finished processing, the response body contains the batch response. This batch response contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems` array which contains a response for each and every query in the batch request. The `batchItems` will contain the results in the exact same order the original queries were sent in the batch request. Each item in `batchItems` contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
     *
     *   - [`RouteDirections`](https://docs.microsoft.com/rest/api/maps/route/getroutedirections#routedirections) - If the query completed successfully.
     *
     *   - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
     *
     *
     * Here's a sample Batch Response with 1 _successful_ and 1 _failed_ result:
     *
     *
     * ```json
     * {
     *     "summary": {
     *         "successfulRequests": 1,
     *         "totalRequests": 2
     *     },
     *     "batchItems": [
     *         {
     *             "statusCode": 200,
     *             "response": {
     *                 "routes": [
     *                     {
     *                         "summary": {
     *                             "lengthInMeters": 1758,
     *                             "travelTimeInSeconds": 387,
     *                             "trafficDelayInSeconds": 0,
     *                             "departureTime": "2018-07-17T00:49:56+00:00",
     *                             "arrivalTime": "2018-07-17T00:56:22+00:00"
     *                         },
     *                         "legs": [
     *                             {
     *                                 "summary": {
     *                                     "lengthInMeters": 1758,
     *                                     "travelTimeInSeconds": 387,
     *                                     "trafficDelayInSeconds": 0,
     *                                     "departureTime": "2018-07-17T00:49:56+00:00",
     *                                     "arrivalTime": "2018-07-17T00:56:22+00:00"
     *                                 },
     *                                 "points": [
     *                                     {
     *                                         "latitude": 47.62094,
     *                                         "longitude": -122.34892
     *                                     },
     *                                     {
     *                                         "latitude": 47.62094,
     *                                         "longitude": -122.3485
     *                                     },
     *                                     {
     *                                         "latitude": 47.62095,
     *                                         "longitude": -122.3476
     *                                     }
     *                                 ]
     *                             }
     *                         ],
     *                         "sections": [
     *                             {
     *                                 "startPointIndex": 0,
     *                                 "endPointIndex": 40,
     *                                 "sectionType": "TRAVEL_MODE",
     *                                 "travelMode": "bicycle"
     *                             }
     *                         ]
     *                     }
     *                 ]
     *             }
     *         },
     *         {
     *             "statusCode": 400,
     *             "response":
     *             {
     *                 "error":
     *                 {
     *                     "code": "400 BadRequest",
     *                     "message": "Bad request: one or more parameters were incorrectly specified or are mutually exclusive."
     *                 }
     *             }
     *         }
     *     ]
     * }
     * ```
     */
    post(options: RouteRequestRouteDirectionsBatchParameters): StreamableMethod<RouteRequestRouteDirectionsBatch200Response | RouteRequestRouteDirectionsBatch202Response>;
    /**
     * **Applies to**: see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * ### Download Asynchronous Batch Results
     * To download the async batch results you will issue a `GET` request to the batch download endpoint. This _download URL_ can be obtained from the `Location` header of a successful `POST` batch request and looks like the following:
     *
     * ```
     * https://atlas.microsoft.com/route/directions/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
     * ```
     * Here's the typical sequence of operations for downloading the batch results:
     * 1. Client sends a `GET` request using the _download URL_.
     * 2. The server will respond with one of the following:
     *
     *     > HTTP `202 Accepted` - Batch request was accepted but is still being processed. Please try again in some time.
     *
     *     > HTTP `200 OK` - Batch request successfully processed. The response body contains all the batch results.
     *
     *
     *
     * ### Batch Response Model
     * The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the batch has finished processing, the response body contains the batch response. This batch response contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems` array which contains a response for each and every query in the batch request. The `batchItems` will contain the results in the exact same order the original queries were sent in the batch request. Each item in `batchItems` contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
     *
     *   - [`RouteDirections`](https://docs.microsoft.com/rest/api/maps/route/getroutedirections#routedirections) - If the query completed successfully.
     *
     *   - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
     *
     *
     * Here's a sample Batch Response with 1 _successful_ and 1 _failed_ result:
     *
     *
     * ```json
     * {
     *     "summary": {
     *         "successfulRequests": 1,
     *         "totalRequests": 2
     *     },
     *     "batchItems": [
     *         {
     *             "statusCode": 200,
     *             "response": {
     *                 "routes": [
     *                     {
     *                         "summary": {
     *                             "lengthInMeters": 1758,
     *                             "travelTimeInSeconds": 387,
     *                             "trafficDelayInSeconds": 0,
     *                             "departureTime": "2018-07-17T00:49:56+00:00",
     *                             "arrivalTime": "2018-07-17T00:56:22+00:00"
     *                         },
     *                         "legs": [
     *                             {
     *                                 "summary": {
     *                                     "lengthInMeters": 1758,
     *                                     "travelTimeInSeconds": 387,
     *                                     "trafficDelayInSeconds": 0,
     *                                     "departureTime": "2018-07-17T00:49:56+00:00",
     *                                     "arrivalTime": "2018-07-17T00:56:22+00:00"
     *                                 },
     *                                 "points": [
     *                                     {
     *                                         "latitude": 47.62094,
     *                                         "longitude": -122.34892
     *                                     },
     *                                     {
     *                                         "latitude": 47.62094,
     *                                         "longitude": -122.3485
     *                                     },
     *                                     {
     *                                         "latitude": 47.62095,
     *                                         "longitude": -122.3476
     *                                     }
     *                                 ]
     *                             }
     *                         ],
     *                         "sections": [
     *                             {
     *                                 "startPointIndex": 0,
     *                                 "endPointIndex": 40,
     *                                 "sectionType": "TRAVEL_MODE",
     *                                 "travelMode": "bicycle"
     *                             }
     *                         ]
     *                     }
     *                 ]
     *             }
     *         },
     *         {
     *             "statusCode": 400,
     *             "response":
     *             {
     *                 "error":
     *                 {
     *                     "code": "400 BadRequest",
     *                     "message": "Bad request: one or more parameters were incorrectly specified or are mutually exclusive."
     *                 }
     *             }
     *         }
     *     ]
     * }
     * ```
     */
    get(options?: RouteGetRouteDirectionsBatchParameters): StreamableMethod<RouteGetRouteDirectionsBatch200Response | RouteGetRouteDirectionsBatch202Response>;
}

export declare interface RequestRouteDirectionsBatchSync {
    /**
     * **Route Directions Batch API**
     *
     *
     * **Applies to**: see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     *
     *
     * The Route Directions Batch API sends batches of queries to [Route Directions API](https://docs.microsoft.com/rest/api/maps/route/getroutedirections) using just a single API call. You can call Route Directions Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to **700** queries and sync API up to **100** queries.
     * ### Submit Synchronous Batch Request
     * The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond as soon as the batch items are calculated and there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer than 60 seconds. The number of batch items is limited to **100** for this API.
     * ```
     * POST https://atlas.microsoft.com/route/directions/batch/sync/json?api-version=1.0&subscription-key={subscription-key}
     * ```
     * ### Batch Response Model
     * The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the batch has finished processing, the response body contains the batch response. This batch response contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems` array which contains a response for each and every query in the batch request. The `batchItems` will contain the results in the exact same order the original queries were sent in the batch request. Each item in `batchItems` contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
     *
     *   - [`RouteDirections`](https://docs.microsoft.com/rest/api/maps/route/getroutedirections#routedirections) - If the query completed successfully.
     *
     *   - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
     *
     *
     * Here's a sample Batch Response with 1 _successful_ and 1 _failed_ result:
     *
     *
     * ```json
     * {
     *     "summary": {
     *         "successfulRequests": 1,
     *         "totalRequests": 2
     *     },
     *     "batchItems": [
     *         {
     *             "statusCode": 200,
     *             "response": {
     *                 "routes": [
     *                     {
     *                         "summary": {
     *                             "lengthInMeters": 1758,
     *                             "travelTimeInSeconds": 387,
     *                             "trafficDelayInSeconds": 0,
     *                             "departureTime": "2018-07-17T00:49:56+00:00",
     *                             "arrivalTime": "2018-07-17T00:56:22+00:00"
     *                         },
     *                         "legs": [
     *                             {
     *                                 "summary": {
     *                                     "lengthInMeters": 1758,
     *                                     "travelTimeInSeconds": 387,
     *                                     "trafficDelayInSeconds": 0,
     *                                     "departureTime": "2018-07-17T00:49:56+00:00",
     *                                     "arrivalTime": "2018-07-17T00:56:22+00:00"
     *                                 },
     *                                 "points": [
     *                                     {
     *                                         "latitude": 47.62094,
     *                                         "longitude": -122.34892
     *                                     },
     *                                     {
     *                                         "latitude": 47.62094,
     *                                         "longitude": -122.3485
     *                                     },
     *                                     {
     *                                         "latitude": 47.62095,
     *                                         "longitude": -122.3476
     *                                     }
     *                                 ]
     *                             }
     *                         ],
     *                         "sections": [
     *                             {
     *                                 "startPointIndex": 0,
     *                                 "endPointIndex": 40,
     *                                 "sectionType": "TRAVEL_MODE",
     *                                 "travelMode": "bicycle"
     *                             }
     *                         ]
     *                     }
     *                 ]
     *             }
     *         },
     *         {
     *             "statusCode": 400,
     *             "response":
     *             {
     *                 "error":
     *                 {
     *                     "code": "400 BadRequest",
     *                     "message": "Bad request: one or more parameters were incorrectly specified or are mutually exclusive."
     *                 }
     *             }
     *         }
     *     ]
     * }
     * ```
     */
    post(options: RouteRequestRouteDirectionsBatchSyncParameters): StreamableMethod<RouteRequestRouteDirectionsBatchSync200Response | RouteRequestRouteDirectionsBatchSync408Response | RouteRequestRouteDirectionsBatchSyncDefaultResponse>;
}

export declare interface RequestRouteMatrix {
    /**
     *
     * **Applies to**: see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * The Matrix Routing service allows calculation of a matrix of route summaries for a set of routes defined by origin and destination locations by using an asynchronous (async) or synchronous (sync) POST request. For every given origin, the service calculates the cost of routing from that origin to every given destination. The set of origins and the set of destinations can be thought of as the column and row headers of a table and each cell in the table contains the costs of routing from the origin to the destination for that cell. As an example, let's say a food delivery company has 20 drivers and they need to find the closest driver to pick up the delivery from the restaurant. To solve this use case, they can call Matrix Route API.
     *
     *
     * For each route, the travel times and distances are returned. You can use the computed costs to determine which detailed routes to calculate using the Route Directions API.
     *
     *
     * The maximum size of a matrix for async request is **700** and for sync request it's **100** (the number of origins multiplied by the number of destinations).
     *
     *
     *
     * ### Submit Synchronous Route Matrix Request
     * If your scenario requires synchronous requests and the maximum size of the matrix is less than or equal to 100, you might want to make synchronous request. The maximum size of a matrix for this API is **100** (the number of origins multiplied by the number of destinations). With that constraint in mind, examples of possible matrix dimensions are: 10x10, 6x8, 9x8 (it does not need to be square).
     *
     * ```
     * POST https://atlas.microsoft.com/route/matrix/sync/json?api-version=1.0&subscription-key={subscription-key}
     * ```
     *
     * ### Submit Asynchronous Route Matrix Request
     * The Asynchronous API is appropriate for processing big volumes of relatively complex routing requests. When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the response header. This URL should be checked periodically until the response data or error information is available. If `waitForResults` parameter in the request is set to true, user will get a 200 response if the request is finished under 120 seconds.
     *
     *
     * The maximum size of a matrix for this API is **700** (the number of origins multiplied by the number of destinations). With that constraint in mind, examples of possible matrix dimensions are: 50x10, 10x10, 28x25. 10x70 (it does not need to be square).
     *
     *
     * The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the expiration period.
     *
     *
     *
     *
     * ```
     * POST https://atlas.microsoft.com/route/matrix/json?api-version=1.0&subscription-key={subscription-key}
     * ```
     *
     * Here's a typical sequence of asynchronous operations:
     * 1. Client sends a Route Matrix POST request to Azure Maps
     *
     * 2. The server will respond with one of the following:
     *
     *     > HTTP `202 Accepted` -  Route Matrix request has been accepted.
     *
     *     > HTTP `Error` - There was an error processing your Route Matrix request. This could either be a 400 Bad Request or any other Error status code.
     *
     *
     * 3. If the Matrix Route request was accepted successfully, the Location header in the response contains the URL to download the results of the request. This status URI looks like the following:
     *
     *   ```
     *     GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
     *   ```
     *
     *
     * 4. Client issues a GET request on the download URL obtained in Step 3 to download the results
     *
     * ### Download Sync Results
     * When you make a POST request for Route Matrix Sync API, the service returns 200 response code for successful request and a response array. The response body will contain the data and there will be no possibility to retrieve the results later.
     *
     * ### Download Async Results
     * When a request issues a `202 Accepted` response, the request is being processed using our async pipeline. You will be given a URL to check the progress of your  async request in the location header of the response. This status URI looks like the following:
     * ```
     *   GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
     * ```
     *
     * The URL provided by the location header will return the following responses when a `GET` request is issued.
     *
     *   > HTTP `202 Accepted` - Matrix request was accepted but is still being processed. Please try again in some time.
     *
     *   > HTTP `200 OK` - Matrix request successfully processed. The response body contains all of the results.
     */
    post(options: RouteRequestRouteMatrixParameters): StreamableMethod<RouteRequestRouteMatrix200Response | RouteRequestRouteMatrix202Response>;
    /**
     * **Applies to**: see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * If the Matrix Route request was accepted successfully, the Location header in the response contains the URL to download the results of the request. This status URI looks like the following:
     *
     *   ```
     *     GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
     *   ```
     *
     *
     * 4. Client issues a GET request on the download URL obtained in Step 3 to download the results
     *
     * ### Download Sync Results
     * When you make a POST request for Route Matrix Sync API, the service returns 200 response code for successful request and a response array. The response body will contain the data and there will be no possibility to retrieve the results later.
     *
     * ### Download Async Results
     * When a request issues a `202 Accepted` response, the request is being processed using our async pipeline. You will be given a URL to check the progress of your  async request in the location header of the response. This status URI looks like the following:
     * ```
     *   GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
     * ```
     *
     * The URL provided by the location header will return the following responses when a `GET` request is issued.
     *
     *   > HTTP `202 Accepted` - Matrix request was accepted but is still being processed. Please try again in some time.
     *
     *   > HTTP `200 OK` - Matrix request successfully processed. The response body contains all of the results.
     */
    get(options?: RouteGetRouteMatrixParameters): StreamableMethod<RouteGetRouteMatrix200Response | RouteGetRouteMatrix202Response>;
}

export declare interface RequestRouteMatrixSync {
    /**
     *
     * **Applies to**: see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
     *
     * The Matrix Routing service allows calculation of a matrix of route summaries for a set of routes defined by origin and destination locations by using an asynchronous (async) or synchronous (sync) POST request. For every given origin, the service calculates the cost of routing from that origin to every given destination. The set of origins and the set of destinations can be thought of as the column and row headers of a table and each cell in the table contains the costs of routing from the origin to the destination for that cell. As an example, let's say a food delivery company has 20 drivers and they need to find the closest driver to pick up the delivery from the restaurant. To solve this use case, they can call Matrix Route API.
     *
     *
     * For each route, the travel times and distances are returned. You can use the computed costs to determine which detailed routes to calculate using the Route Directions API.
     *
     *
     * The maximum size of a matrix for async request is **700** and for sync request it's **100** (the number of origins multiplied by the number of destinations).
     *
     *
     *
     * ### Submit Synchronous Route Matrix Request
     * If your scenario requires synchronous requests and the maximum size of the matrix is less than or equal to 100, you might want to make synchronous request. The maximum size of a matrix for this API is **100** (the number of origins multiplied by the number of destinations). With that constraint in mind, examples of possible matrix dimensions are: 10x10, 6x8, 9x8 (it does not need to be square).
     *
     * ```
     * POST https://atlas.microsoft.com/route/matrix/sync/json?api-version=1.0&subscription-key={subscription-key}
     * ```
     *
     * ### Submit Asynchronous Route Matrix Request
     * The Asynchronous API is appropriate for processing big volumes of relatively complex routing requests. When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the response header. This URL should be checked periodically until the response data or error information is available. If `waitForResults` parameter in the request is set to true, user will get a 200 response if the request is finished under 120 seconds.
     *
     *
     * The maximum size of a matrix for this API is **700** (the number of origins multiplied by the number of destinations). With that constraint in mind, examples of possible matrix dimensions are: 50x10, 10x10, 28x25. 10x70 (it does not need to be square).
     *
     *
     * The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the expiration period.
     *
     *
     *
     *
     * ```
     * POST https://atlas.microsoft.com/route/matrix/json?api-version=1.0&subscription-key={subscription-key}
     * ```
     *
     * Here's a typical sequence of asynchronous operations:
     * 1. Client sends a Route Matrix POST request to Azure Maps
     *
     * 2. The server will respond with one of the following:
     *
     *     > HTTP `202 Accepted` -  Route Matrix request has been accepted.
     *
     *     > HTTP `Error` - There was an error processing your Route Matrix request. This could either be a 400 Bad Request or any other Error status code.
     *
     *
     * 3. If the Matrix Route request was accepted successfully, the Location header in the response contains the URL to download the results of the request. This status URI looks like the following:
     *
     *   ```
     *     GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
     *   ```
     *
     *
     * 4. Client issues a GET request on the download URL obtained in Step 3 to download the results
     *
     * ### Download Sync Results
     * When you make a POST request for Route Matrix Sync API, the service returns 200 response code for successful request and a response array. The response body will contain the data and there will be no possibility to retrieve the results later.
     *
     * ### Download Async Results
     * When a request issues a `202 Accepted` response, the request is being processed using our async pipeline. You will be given a URL to check the progress of your  async request in the location header of the response. This status URI looks like the following:
     * ```
     *   GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
     * ```
     *
     * The URL provided by the location header will return the following responses when a `GET` request is issued.
     *
     *   > HTTP `202 Accepted` - Matrix request was accepted but is still being processed. Please try again in some time.
     *
     *   > HTTP `200 OK` - Matrix request successfully processed. The response body contains all of the results.
     */
    post(options: RouteRequestRouteMatrixSyncParameters): StreamableMethod<RouteRequestRouteMatrixSync200Response | RouteRequestRouteMatrixSync408Response | RouteRequestRouteMatrixSyncDefaultResponse>;
}

/** Post body parameters for Route directions. */
export declare interface RouteDirectionParameters {
    /**
     * A GeoJSON Geometry collection representing sequence of coordinates used as input for route reconstruction and for calculating zero or more alternative routes to this reference route.
     *   - The provided sequence of supporting points is used as input for route reconstruction.
     *   - The alternative routes are calculated between the origin and destination points specified in the base path parameter locations.
     *   - If both _minDeviationDistance_ and _minDeviationTime_ are set to zero, then these origin and destination points are
     *   expected to be at (or very near) the beginning and end of the reference route, respectively.
     *   - Intermediate locations (_waypoints_) are not supported when using <_supportingPoints_>.
     *   - The reference route may contain traffic incidents of type _ROAD_CLOSURE_, which are
     *   ignored for the calculation of the reference route's travel time and traffic delay.
     */
    supportingPoints?: Record<string, unknown>;
    /** This is a list of 3-character, ISO 3166-1, alpha-3 country codes of countries in which all toll roads with vignettes are to be avoided, e.g. "AUS,CHE". Toll roads with vignettes in countries not in the list are unaffected. Note: It is an error to specify both **avoidVignette** and **allowVignette**. */
    avoidVignette?: Array<string>;
    /** This is a list of 3-character, ISO 3166-1, alpha-3 country codes of countries in which toll roads with vignettes are allowed, e.g. "AUS,CHE". Specifying **allowVignette** with some countries X is equivalent to specifying **avoidVignette** with all countries but X. Specifying **allowVignette** with an empty list is the same as avoiding all toll roads with vignettes. Note: It is an error to specify both **avoidVignette** and **allowVignette**. */
    allowVignette?: Array<string>;
    /** A GeoJSON MultiPolygon representing list of areas to avoid. Only rectangle polygons are supported. The maximum size of a rectangle is about 160x160 km. Maximum number of avoided areas is **10**. It cannot cross the 180th meridian. It must be between -80 and +80 degrees of latitude. */
    avoidAreas?: GeoJsonMultiPolygon;
}

/** An item returned from Route Directions Batch service call. */
export declare interface RouteDirectionsBatchItemOutput extends BatchResultItemOutput {
    /** The result of the query. RouteDirections if the query completed successfully, ErrorResponse otherwise. */
    response: RouteDirectionsBatchItemResponseOutput;
}

/** The result of the query. RouteDirections if the query completed successfully, ErrorResponse otherwise. */
export declare interface RouteDirectionsBatchItemResponseOutput extends RouteDirectionsOutput, ErrorResponseOutput {
}

/** This object is returned from a successful Route Directions Batch service call. */
export declare interface RouteDirectionsBatchResultOutput extends BatchResultOutput {
    /** Array containing the batch results. */
    batchItems: Array<RouteDirectionsBatchItemOutput>;
}

/** This object is returned from a successful Route Directions call */
export declare interface RouteDirectionsOutput {
    /** Format Version property */
    formatVersion?: string;
    /** Routes array */
    routes: Array<RouteOutput>;
    /**
     * Optimized sequence of waypoints. It shows the index from the user provided waypoint sequence for the original and optimized list. For instance, a response:
     *
     * ```
     * <optimizedWaypoints>
     * <waypoint providedIndex="0" optimizedIndex="1"/>
     * <waypoint providedIndex="1" optimizedIndex="2"/>
     * <waypoint providedIndex="2" optimizedIndex="0"/>
     * </optimizedWaypoints>
     * ```
     *
     * means that the original sequence is [0, 1, 2] and optimized sequence is [1, 2, 0]. Since the index starts by 0 the original is "first, second, third" while the optimized is "second, third, first".
     */
    optimizedWaypoints?: Array<RouteOptimizedWaypointOutput>;
    /** Reports the effective settings used in the current call. */
    report?: RouteReportOutput;
}

/**
 * **Applies to**: see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
 *
 *
 * Returns  a route between an origin and a destination, passing through waypoints if they are specified. The route will take into account factors such as current traffic and the typical road speeds on the requested day of the week and time of day.
 *
 * Information returned includes the distance, estimated travel time, and a representation of the route geometry. Additional routing information such as optimized waypoint order or turn by turn instructions is also available, depending on the options selected.
 *
 * Routing service provides a set of parameters for a detailed description of vehicle-specific Consumption Model. Please check [Consumption Model](https://docs.microsoft.com/azure/azure-maps/consumption-model) for detailed explanation of the concepts and parameters involved.
 */
export declare interface RouteGetRouteDirections200Response extends HttpResponse {
    status: "200";
    body: RouteDirectionsOutput;
}

/**
 * **Applies to**: see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
 *
 * ### Download Asynchronous Batch Results
 * To download the async batch results you will issue a `GET` request to the batch download endpoint. This _download URL_ can be obtained from the `Location` header of a successful `POST` batch request and looks like the following:
 *
 * ```
 * https://atlas.microsoft.com/route/directions/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
 * ```
 * Here's the typical sequence of operations for downloading the batch results:
 * 1. Client sends a `GET` request using the _download URL_.
 * 2. The server will respond with one of the following:
 *
 *     > HTTP `202 Accepted` - Batch request was accepted but is still being processed. Please try again in some time.
 *
 *     > HTTP `200 OK` - Batch request successfully processed. The response body contains all the batch results.
 *
 *
 *
 * ### Batch Response Model
 * The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the batch has finished processing, the response body contains the batch response. This batch response contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems` array which contains a response for each and every query in the batch request. The `batchItems` will contain the results in the exact same order the original queries were sent in the batch request. Each item in `batchItems` contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
 *
 *   - [`RouteDirections`](https://docs.microsoft.com/rest/api/maps/route/getroutedirections#routedirections) - If the query completed successfully.
 *
 *   - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
 *
 *
 * Here's a sample Batch Response with 1 _successful_ and 1 _failed_ result:
 *
 *
 * ```json
 * {
 *     "summary": {
 *         "successfulRequests": 1,
 *         "totalRequests": 2
 *     },
 *     "batchItems": [
 *         {
 *             "statusCode": 200,
 *             "response": {
 *                 "routes": [
 *                     {
 *                         "summary": {
 *                             "lengthInMeters": 1758,
 *                             "travelTimeInSeconds": 387,
 *                             "trafficDelayInSeconds": 0,
 *                             "departureTime": "2018-07-17T00:49:56+00:00",
 *                             "arrivalTime": "2018-07-17T00:56:22+00:00"
 *                         },
 *                         "legs": [
 *                             {
 *                                 "summary": {
 *                                     "lengthInMeters": 1758,
 *                                     "travelTimeInSeconds": 387,
 *                                     "trafficDelayInSeconds": 0,
 *                                     "departureTime": "2018-07-17T00:49:56+00:00",
 *                                     "arrivalTime": "2018-07-17T00:56:22+00:00"
 *                                 },
 *                                 "points": [
 *                                     {
 *                                         "latitude": 47.62094,
 *                                         "longitude": -122.34892
 *                                     },
 *                                     {
 *                                         "latitude": 47.62094,
 *                                         "longitude": -122.3485
 *                                     },
 *                                     {
 *                                         "latitude": 47.62095,
 *                                         "longitude": -122.3476
 *                                     }
 *                                 ]
 *                             }
 *                         ],
 *                         "sections": [
 *                             {
 *                                 "startPointIndex": 0,
 *                                 "endPointIndex": 40,
 *                                 "sectionType": "TRAVEL_MODE",
 *                                 "travelMode": "bicycle"
 *                             }
 *                         ]
 *                     }
 *                 ]
 *             }
 *         },
 *         {
 *             "statusCode": 400,
 *             "response":
 *             {
 *                 "error":
 *                 {
 *                     "code": "400 BadRequest",
 *                     "message": "Bad request: one or more parameters were incorrectly specified or are mutually exclusive."
 *                 }
 *             }
 *         }
 *     ]
 * }
 * ```
 */
export declare interface RouteGetRouteDirectionsBatch200Response extends HttpResponse {
    status: "200";
    body: RouteDirectionsBatchResultOutput;
}

export declare interface RouteGetRouteDirectionsBatch202Headers {
    /** New URL to check for the results of the long running process. */
    location?: string;
}

/**
 * **Applies to**: see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
 *
 * ### Download Asynchronous Batch Results
 * To download the async batch results you will issue a `GET` request to the batch download endpoint. This _download URL_ can be obtained from the `Location` header of a successful `POST` batch request and looks like the following:
 *
 * ```
 * https://atlas.microsoft.com/route/directions/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
 * ```
 * Here's the typical sequence of operations for downloading the batch results:
 * 1. Client sends a `GET` request using the _download URL_.
 * 2. The server will respond with one of the following:
 *
 *     > HTTP `202 Accepted` - Batch request was accepted but is still being processed. Please try again in some time.
 *
 *     > HTTP `200 OK` - Batch request successfully processed. The response body contains all the batch results.
 *
 *
 *
 * ### Batch Response Model
 * The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the batch has finished processing, the response body contains the batch response. This batch response contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems` array which contains a response for each and every query in the batch request. The `batchItems` will contain the results in the exact same order the original queries were sent in the batch request. Each item in `batchItems` contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
 *
 *   - [`RouteDirections`](https://docs.microsoft.com/rest/api/maps/route/getroutedirections#routedirections) - If the query completed successfully.
 *
 *   - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
 *
 *
 * Here's a sample Batch Response with 1 _successful_ and 1 _failed_ result:
 *
 *
 * ```json
 * {
 *     "summary": {
 *         "successfulRequests": 1,
 *         "totalRequests": 2
 *     },
 *     "batchItems": [
 *         {
 *             "statusCode": 200,
 *             "response": {
 *                 "routes": [
 *                     {
 *                         "summary": {
 *                             "lengthInMeters": 1758,
 *                             "travelTimeInSeconds": 387,
 *                             "trafficDelayInSeconds": 0,
 *                             "departureTime": "2018-07-17T00:49:56+00:00",
 *                             "arrivalTime": "2018-07-17T00:56:22+00:00"
 *                         },
 *                         "legs": [
 *                             {
 *                                 "summary": {
 *                                     "lengthInMeters": 1758,
 *                                     "travelTimeInSeconds": 387,
 *                                     "trafficDelayInSeconds": 0,
 *                                     "departureTime": "2018-07-17T00:49:56+00:00",
 *                                     "arrivalTime": "2018-07-17T00:56:22+00:00"
 *                                 },
 *                                 "points": [
 *                                     {
 *                                         "latitude": 47.62094,
 *                                         "longitude": -122.34892
 *                                     },
 *                                     {
 *                                         "latitude": 47.62094,
 *                                         "longitude": -122.3485
 *                                     },
 *                                     {
 *                                         "latitude": 47.62095,
 *                                         "longitude": -122.3476
 *                                     }
 *                                 ]
 *                             }
 *                         ],
 *                         "sections": [
 *                             {
 *                                 "startPointIndex": 0,
 *                                 "endPointIndex": 40,
 *                                 "sectionType": "TRAVEL_MODE",
 *                                 "travelMode": "bicycle"
 *                             }
 *                         ]
 *                     }
 *                 ]
 *             }
 *         },
 *         {
 *             "statusCode": 400,
 *             "response":
 *             {
 *                 "error":
 *                 {
 *                     "code": "400 BadRequest",
 *                     "message": "Bad request: one or more parameters were incorrectly specified or are mutually exclusive."
 *                 }
 *             }
 *         }
 *     ]
 * }
 * ```
 */
export declare interface RouteGetRouteDirectionsBatch202Response extends HttpResponse {
    status: "202";
    body: Record<string, unknown>;
    headers: RawHttpHeaders & RouteGetRouteDirectionsBatch202Headers;
}

export declare type RouteGetRouteDirectionsBatchParameters = RequestParameters;

/**
 * **Applies to**: see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
 *
 *
 * Returns  a route between an origin and a destination, passing through waypoints if they are specified. The route will take into account factors such as current traffic and the typical road speeds on the requested day of the week and time of day.
 *
 * Information returned includes the distance, estimated travel time, and a representation of the route geometry. Additional routing information such as optimized waypoint order or turn by turn instructions is also available, depending on the options selected.
 *
 * Routing service provides a set of parameters for a detailed description of vehicle-specific Consumption Model. Please check [Consumption Model](https://docs.microsoft.com/azure/azure-maps/consumption-model) for detailed explanation of the concepts and parameters involved.
 */
export declare interface RouteGetRouteDirectionsDefaultResponse extends HttpResponse {
    status: string;
    body: ErrorResponseOutput;
}

export declare type RouteGetRouteDirectionsParameters = RouteGetRouteDirectionsQueryParam & RequestParameters;

export declare interface RouteGetRouteDirectionsQueryParam {
    queryParameters: RouteGetRouteDirectionsQueryParamProperties;
}

export declare interface RouteGetRouteDirectionsQueryParamProperties {
    /** The Coordinates through which the route is calculated, delimited by a colon.  A minimum of two coordinates is required.  The first one is the origin and the last is the destination of the route. Optional coordinates in-between act as WayPoints in the route.  You can pass up to 150 WayPoints. */
    query: string;
    /** Number of desired alternative routes to be calculated. Default: 0, minimum: 0 and maximum: 5 */
    maxAlternatives?: number;
    /** Controls the optimality, with respect to the given planning criteria, of the calculated alternatives compared to the reference route. */
    alternativeType?: "anyRoute" | "betterRoute";
    /** All alternative routes returned will follow the reference route (see section POST Requests) from the origin point of the calculateRoute request for at least this number of meters. Can only be used when reconstructing a route. The minDeviationDistance parameter cannot be used in conjunction with arriveAt */
    minDeviationDistance?: number;
    /** The date and time of arrival at the destination point. It must be specified as a dateTime. When a time zone offset is not specified it will be assumed to be that of the destination point. The arriveAt value must be in the future. The arriveAt parameter cannot be used in conjunction with departAt, minDeviationDistance or minDeviationTime. */
    arriveAt?: Date | string;
    /** The date and time of departure from the origin point. Departure times apart from now must be specified as a dateTime. When a time zone offset is not specified, it will be assumed to be that of the origin point. The departAt value must be in the future in the date-time format (1996-12-19T16:39:57-08:00). */
    departAt?: Date | string;
    /**
     * All alternative routes returned will follow the reference route (see section POST Requests) from the origin point of the calculateRoute request for at least this number of seconds. Can only be used when reconstructing a route. The minDeviationTime parameter cannot be used in conjunction with arriveAt. Default value is 0. Setting )minDeviationTime_ to a value greater than zero has the following consequences:
     *   - The origin point of the _calculateRoute_ Request must be on
     *     (or very near) the input reference route.
     *     - If this is not the case, an error is returned.
     *     - However, the origin point does not need to be at the beginning
     *       of the input reference route (it can be thought of as the current
     *       vehicle position on the reference route).
     *   - The reference route, returned as the first route in the _calculateRoute_
     *     Response, will start at the origin point specified in the _calculateRoute_
     *     Request. The initial part of the input reference route up until the origin
     *     point will be excluded from the Response.
     *   - The values of _minDeviationDistance_ and _minDeviationTime_ determine
     *     how far alternative routes will be guaranteed to follow the reference
     *     route from the origin point onwards.
     *   - The route must use _departAt_.
     *   - The _vehicleHeading_ is ignored.
     */
    minDeviationTime?: number;
    /** If specified, guidance instructions will be returned. Note that the instructionsType parameter cannot be used in conjunction with routeRepresentation=none */
    instructionsType?: "coded" | "text" | "tagged";
    /**
     * The language parameter determines the language of the guidance messages. Proper nouns (the names of streets, plazas, etc.) are returned in the specified  language, or if that is not available, they are returned in an available language  that is close to it. Allowed values are (a subset of) the IETF language tags. The currently supported  languages are listed in the [Supported languages  section](https://docs.microsoft.com/azure/azure-maps/supported-languages).
     *
     * Default value: en-GB
     */
    language?: string;
    /** Re-order the route waypoints using a fast heuristic algorithm to reduce the route length. Yields best results when used in conjunction with routeType _shortest_. Notice that origin and destination are excluded from the optimized waypoint indices. To include origin and destination in the response, please increase all the indices by 1 to account for the origin, and then add the destination as the final index. Possible values are true or false. True computes a better order if possible, but is not allowed to be used in conjunction with maxAlternatives value greater than 0 or in conjunction with circle waypoints. False will use the locations in the given order and not allowed to be used in conjunction with routeRepresentation _none_. */
    computeBestOrder?: boolean;
    /** Specifies the representation of the set of routes provided as response. This parameter value can only be used in conjunction with computeBestOrder=true. */
    routeRepresentation?: "polyline" | "summaryOnly" | "none";
    /** Specifies whether to return additional travel times using different types of traffic information (none, historic, live) as well as the default best-estimate travel time. */
    computeTravelTimeFor?: "none" | "all";
    /** The directional heading of the vehicle in degrees starting at true North and continuing in clockwise direction. North is 0 degrees, east is 90 degrees, south is 180 degrees, west is 270 degrees. Possible values 0-359 */
    vehicleHeading?: number;
    /** Specifies which data should be reported for diagnosis purposes. The only possible value is _effectiveSettings_. Reports the effective parameters or data used when calling the API. In the case of defaulted parameters the default will be reflected where the parameter was not specified by the caller. */
    report?: "effectiveSettings";
    /** Specifies which of the section types is reported in the route response. <br><br>For example if sectionType = pedestrian the sections which are suited for pedestrians only are returned. Multiple types can be used. The default sectionType refers to the travelMode input. By default travelMode is set to car */
    sectionType?: "carTrain" | "country" | "ferry" | "motorway" | "pedestrian" | "tollRoad" | "tollVignette" | "traffic" | "travelMode" | "tunnel" | "carpool" | "urban";
    /** Weight per axle of the vehicle in kg. A value of 0 means that weight restrictions per axle are not considered. */
    vehicleAxleWeight?: number;
    /** Width of the vehicle in meters. A value of 0 means that width restrictions are not considered. */
    vehicleWidth?: number;
    /** Height of the vehicle in meters. A value of 0 means that height restrictions are not considered. */
    vehicleHeight?: number;
    /** Length of the vehicle in meters. A value of 0 means that length restrictions are not considered. */
    vehicleLength?: number;
    /**
     * Maximum speed of the vehicle in km/hour. The max speed in the vehicle profile is used to check whether a vehicle is allowed on motorways.
     *
     * * A value of 0 means that an appropriate value for the vehicle will be determined and applied during route planning.
     *
     * * A non-zero value may be overridden during route planning. For example, the current traffic flow is 60 km/hour. If the vehicle  maximum speed is set to 50 km/hour, the routing engine will consider 60 km/hour as this is the current situation.  If the maximum speed of the vehicle is provided as 80 km/hour but the current traffic flow is 60 km/hour, then routing engine will again use 60 km/hour.
     */
    vehicleMaxSpeed?: number;
    /**
     * Weight of the vehicle in kilograms.
     *
     * * It is mandatory if any of the *Efficiency parameters are set.
     *
     * * It must be strictly positive when used in the context of the Consumption Model. Weight restrictions are considered.
     *
     * * If no detailed **Consumption Model** is specified and the value of **vehicleWeight** is non-zero, then weight restrictions are considered.
     *
     * * In all other cases, this parameter is ignored.
     *
     * Sensible Values : for **Combustion Model** : 1600, for **Electric Model** : 1900
     */
    vehicleWeight?: number;
    /** Whether the vehicle is used for commercial purposes. Commercial vehicles may not be allowed to drive on some roads. */
    vehicleCommercial?: boolean;
    /** Level of turns for thrilling route. This parameter can only be used in conjunction with `routeType`=thrilling. */
    windingness?: "low" | "normal" | "high";
    /** Degree of hilliness for thrilling route. This parameter can only be used in conjunction with `routeType`=thrilling. */
    hilliness?: "low" | "normal" | "high";
    /** The mode of travel for the requested route. If not defined, default is 'car'. Note that the requested travelMode may not be available for the entire route. Where the requested travelMode is not available for a particular section, the travelMode element of the response for that section will be "other". Note that travel modes bus, motorcycle, taxi and van are BETA functionality. Full restriction data is not available in all areas. In **calculateReachableRange** requests, the values bicycle and pedestrian must not be used. */
    travelMode?: "car" | "truck" | "taxi" | "bus" | "van" | "motorcycle" | "bicycle" | "pedestrian";
    /** Specifies something that the route calculation should try to avoid when determining the route. Can be specified multiple times in one request, for example, '&avoid=motorways&avoid=tollRoads&avoid=ferries'. In calculateReachableRange requests, the value alreadyUsedRoads must not be used. */
    avoid?: Array<"tollRoads" | "motorways" | "ferries" | "unpavedRoads" | "carpools" | "alreadyUsedRoads" | "borderCrossings">;
    /**
     * Possible values:
     *   * true - Do consider all available traffic information during routing
     *   * false - Ignore current traffic data during routing. Note that although the current traffic data is ignored
     *   during routing, the effect of historic traffic on effective road speeds is still incorporated.
     */
    traffic?: boolean;
    /** The type of route requested. */
    routeType?: "fastest" | "shortest" | "eco" | "thrilling";
    /** Types of cargo that may be classified as hazardous materials and restricted from some roads. Available vehicleLoadType values are US Hazmat classes 1 through 9, plus generic classifications for use in other countries. Values beginning with USHazmat are for US routing while otherHazmat should be used for all other countries. vehicleLoadType can be specified multiple times. This parameter is currently only considered for travelMode=truck. */
    vehicleLoadType?: "USHazmatClass1" | "USHazmatClass2" | "USHazmatClass3" | "USHazmatClass4" | "USHazmatClass5" | "USHazmatClass6" | "USHazmatClass7" | "USHazmatClass8" | "USHazmatClass9" | "otherHazmatExplosive" | "otherHazmatGeneral" | "otherHazmatHarmfulToWater";
    /** Engine type of the vehicle. When a detailed Consumption Model is specified, it must be consistent with the value of **vehicleEngineType**. */
    vehicleEngineType?: "combustion" | "electric";
    /**
     *
     * Specifies the speed-dependent component of consumption.
     *
     * Provided as an unordered list of colon-delimited speed & consumption-rate pairs. The list defines points on a consumption curve. Consumption rates for speeds not in the list are found as follows:
     *
     *  * by linear interpolation, if the given speed lies in between two speeds in the list
     *
     *  * by linear extrapolation otherwise, assuming a constant (Consumption/Speed) determined by the nearest two points in the list
     *
     * The list must contain between 1 and 25 points (inclusive), and may not contain duplicate points for the same speed. If it only contains a single point, then the consumption rate of that point is used without further processing.
     *
     * Consumption specified for the largest speed must be greater than or equal to that of the penultimate largest speed. This ensures that extrapolation does not lead to negative consumption rates.
     *
     * Similarly, consumption values specified for the two smallest speeds in the list cannot lead to a negative consumption rate for any smaller speed.
     *
     * The valid range for the consumption values(expressed in l/100km) is between 0.01 and 100000.0.
     *
     * Sensible Values : 50,6.3:130,11.5
     *
     * **Note** : This parameter is required for **The Combustion Consumption Model**.
     */
    constantSpeedConsumptionInLitersPerHundredkm?: string;
    /**
     * Specifies the current supply of fuel in liters.
     *
     * Sensible Values : 55
     */
    currentFuelInLiters?: number;
    /**
     * Specifies the amount of fuel consumed for sustaining auxiliary systems of the vehicle, in liters per hour.
     *
     * It can be used to specify consumption due to devices and systems such as AC systems, radio, heating, etc.
     *
     * Sensible Values : 0.2
     */
    auxiliaryPowerInLitersPerHour?: number;
    /**
     * Specifies the amount of chemical energy stored in one liter of fuel in megajoules (MJ). It is used in conjunction with the ***Efficiency** parameters for conversions between saved or consumed energy and fuel. For example, energy density is 34.2 MJ/l for gasoline, and 35.8 MJ/l for Diesel fuel.
     *
     * This parameter is required if any ***Efficiency** parameter is set.
     *
     * Sensible Values : 34.2
     */
    fuelEnergyDensityInMJoulesPerLiter?: number;
    /**
     * Specifies the efficiency of converting chemical energy stored in fuel to kinetic energy when the vehicle accelerates _(i.e. KineticEnergyGained/ChemicalEnergyConsumed). ChemicalEnergyConsumed_ is obtained by converting consumed fuel to chemical energy using **fuelEnergyDensityInMJoulesPerLiter**.
     *
     * Must be paired with **decelerationEfficiency**.
     *
     * The range of values allowed are 0.0 to 1/**decelerationEfficiency**.
     *
     * Sensible Values : for **Combustion Model** : 0.33, for **Electric Model** : 0.66
     */
    accelerationEfficiency?: number;
    /**
     * Specifies the efficiency of converting kinetic energy to saved (not consumed) fuel when the vehicle decelerates _(i.e. ChemicalEnergySaved/KineticEnergyLost). ChemicalEnergySaved_ is obtained by converting saved (not consumed) fuel to energy using **fuelEnergyDensityInMJoulesPerLiter**.
     *
     * Must be paired with **accelerationEfficiency**.
     *
     * The range of values allowed are 0.0 to 1/**accelerationEfficiency**.
     *
     * Sensible Values : for **Combustion Model** : 0.83, for **Electric Model** : 0.91
     */
    decelerationEfficiency?: number;
    /**
     * Specifies the efficiency of converting chemical energy stored in fuel to potential energy when the vehicle gains elevation _(i.e. PotentialEnergyGained/ChemicalEnergyConsumed). ChemicalEnergyConsumed_ is obtained by converting consumed fuel to chemical energy using **fuelEnergyDensityInMJoulesPerLiter**.
     *
     * Must be paired with **downhillEfficiency**.
     *
     * The range of values allowed are 0.0 to 1/**downhillEfficiency**.
     *
     * Sensible Values : for **Combustion Model** : 0.27, for **Electric Model** : 0.74
     */
    uphillEfficiency?: number;
    /**
     * Specifies the efficiency of converting potential energy to saved (not consumed) fuel when the vehicle loses elevation _(i.e. ChemicalEnergySaved/PotentialEnergyLost). ChemicalEnergySaved_ is obtained by converting saved (not consumed) fuel to energy using **fuelEnergyDensityInMJoulesPerLiter**.
     *
     * Must be paired with **uphillEfficiency**.
     *
     * The range of values allowed are 0.0 to 1/**uphillEfficiency**.
     *
     * Sensible Values : for **Combustion Model** : 0.51, for **Electric Model** : 0.73
     */
    downhillEfficiency?: number;
    /**
     * Specifies the speed-dependent component of consumption.
     *
     * Provided as an unordered list of speed/consumption-rate pairs. The list defines points on a consumption curve. Consumption rates for speeds not in the list are found as follows:
     *
     * * by linear interpolation, if the given speed lies in between two speeds in the list
     *
     * * by linear extrapolation otherwise, assuming a constant (Consumption/Speed) determined by the nearest two points in the list
     *
     * The list must contain between 1 and 25 points (inclusive), and may not contain duplicate points for the same speed. If it only contains a single point, then the consumption rate of that point is used without further processing.
     *
     * Consumption specified for the largest speed must be greater than or equal to that of the penultimate largest speed. This ensures that extrapolation does not lead to negative consumption rates.
     *
     * Similarly, consumption values specified for the two smallest speeds in the list cannot lead to a negative consumption rate for any smaller  speed.
     *
     * The valid range for the consumption values(expressed in kWh/100km) is between 0.01 and 100000.0.
     *
     * Sensible Values : 50,8.2:130,21.3
     *
     * This parameter is required for **Electric consumption model**.
     */
    constantSpeedConsumptionInkWhPerHundredkm?: string;
    /**
     * Specifies the current electric energy supply in kilowatt hours (kWh).
     *
     * This parameter co-exists with **maxChargeInkWh** parameter.
     *
     * The range of values allowed are 0.0 to **maxChargeInkWh**.
     *
     * Sensible Values : 43
     */
    currentChargeInkWh?: number;
    /**
     * Specifies the maximum electric energy supply in kilowatt hours (kWh) that may be stored in the vehicle's battery.
     *
     * This parameter co-exists with **currentChargeInkWh** parameter.
     *
     * Minimum value has to be greater than or equal to **currentChargeInkWh**.
     *
     * Sensible Values : 85
     */
    maxChargeInkWh?: number;
    /**
     * Specifies the amount of power consumed for sustaining auxiliary systems, in kilowatts (kW).
     *
     * It can be used to specify consumption due to devices and systems such as AC systems, radio, heating, etc.
     *
     * Sensible Values : 1.7
     */
    auxiliaryPowerInkW?: number;
}

/**
 * **Applies to**: see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
 *
 *
 * Returns  a route between an origin and a destination, passing through waypoints if they are specified. The route will take into account factors such as current traffic and the typical road speeds on the requested day of the week and time of day.
 *
 * Information returned includes the distance, estimated travel time, and a representation of the route geometry. Additional routing information such as optimized waypoint order or turn by turn instructions is also available, depending on the options selected.
 *
 * Routing service provides a set of parameters for a detailed description of a vehicle-specific Consumption Model. Please check [Consumption Model](https://docs.microsoft.com/azure/azure-maps/consumption-model) for detailed explanation of the concepts and parameters involved.
 */
export declare interface RouteGetRouteDirectionsWithAdditionalParameters200Response extends HttpResponse {
    status: "200";
    body: RouteDirectionsOutput;
}

export declare interface RouteGetRouteDirectionsWithAdditionalParametersBodyParam {
    /**
     * Used for reconstructing a route and for calculating zero or more alternative routes to this reference route.  The provided sequence of coordinates is used as input for route reconstruction. The alternative routes  are calculated between the origin and destination points specified in the base path parameter locations.  If both minDeviationDistance and minDeviationTime are set to zero, then these origin and destination points  are expected to be at (or very near) the beginning and end of the reference route, respectively. Intermediate  locations (waypoints) are not supported when using supportingPoints.
     *
     * Setting at least one of minDeviationDistance or minDeviationTime to a value greater than zero has the  following consequences:
     *
     * *  The origin point of the calculateRoute request must be on (or very near) the input reference route. If  this is not the case, an error is returned. However, the origin point does not need to be at the beginning of  the input reference route (it can be thought of as the current vehicle position on the reference route).
     * *  The reference route, returned as the first route in the calculateRoute response, will start at the origin  point specified in the calculateRoute request. The initial part of the input reference route up until the  origin point will be excluded from the response.
     * *  The values of minDeviationDistance and minDeviationTime determine how far alternative routes will be  guaranteed to follow the reference route from the origin point onwards.
     * *  The route must use departAt.
     * *  The vehicleHeading is ignored.
     */
    body: RouteDirectionParameters;
}

/**
 * **Applies to**: see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
 *
 *
 * Returns  a route between an origin and a destination, passing through waypoints if they are specified. The route will take into account factors such as current traffic and the typical road speeds on the requested day of the week and time of day.
 *
 * Information returned includes the distance, estimated travel time, and a representation of the route geometry. Additional routing information such as optimized waypoint order or turn by turn instructions is also available, depending on the options selected.
 *
 * Routing service provides a set of parameters for a detailed description of a vehicle-specific Consumption Model. Please check [Consumption Model](https://docs.microsoft.com/azure/azure-maps/consumption-model) for detailed explanation of the concepts and parameters involved.
 */
export declare interface RouteGetRouteDirectionsWithAdditionalParametersDefaultResponse extends HttpResponse {
    status: string;
    body: ErrorResponseOutput;
}

export declare interface RouteGetRouteDirectionsWithAdditionalParametersMediaTypesParam {
    /** Request content type */
    contentType?: "application/json";
}

export declare type RouteGetRouteDirectionsWithAdditionalParametersParameters = RouteGetRouteDirectionsWithAdditionalParametersQueryParam & RouteGetRouteDirectionsWithAdditionalParametersMediaTypesParam & RouteGetRouteDirectionsWithAdditionalParametersBodyParam & RequestParameters;

export declare interface RouteGetRouteDirectionsWithAdditionalParametersQueryParam {
    queryParameters: RouteGetRouteDirectionsWithAdditionalParametersQueryParamProperties;
}

export declare interface RouteGetRouteDirectionsWithAdditionalParametersQueryParamProperties {
    /** The Coordinates through which the route is calculated, delimited by a colon.  A minimum of two coordinates is required.  The first one is the origin and the last is the destination of the route. Optional coordinates in-between act as WayPoints in the route.  You can pass up to 150 WayPoints. */
    query: string;
    /** Number of desired alternative routes to be calculated. Default: 0, minimum: 0 and maximum: 5 */
    maxAlternatives?: number;
    /** Controls the optimality, with respect to the given planning criteria, of the calculated alternatives compared to the reference route. */
    alternativeType?: "anyRoute" | "betterRoute";
    /** All alternative routes returned will follow the reference route (see section POST Requests) from the origin point of the calculateRoute request for at least this number of meters. Can only be used when reconstructing a route. The minDeviationDistance parameter cannot be used in conjunction with arriveAt */
    minDeviationDistance?: number;
    /**
     * All alternative routes returned will follow the reference route (see section POST Requests) from the origin point of the calculateRoute request for at least this number of seconds. Can only be used when reconstructing a route. The minDeviationTime parameter cannot be used in conjunction with arriveAt. Default value is 0. Setting )minDeviationTime_ to a value greater than zero has the following consequences:
     *   - The origin point of the _calculateRoute_ Request must be on
     *     (or very near) the input reference route.
     *     - If this is not the case, an error is returned.
     *     - However, the origin point does not need to be at the beginning
     *       of the input reference route (it can be thought of as the current
     *       vehicle position on the reference route).
     *   - The reference route, returned as the first route in the _calculateRoute_
     *     Response, will start at the origin point specified in the _calculateRoute_
     *     Request. The initial part of the input reference route up until the origin
     *     point will be excluded from the Response.
     *   - The values of _minDeviationDistance_ and _minDeviationTime_ determine
     *     how far alternative routes will be guaranteed to follow the reference
     *     route from the origin point onwards.
     *   - The route must use _departAt_.
     *   - The _vehicleHeading_ is ignored.
     */
    minDeviationTime?: number;
    /** If specified, guidance instructions will be returned. Note that the instructionsType parameter cannot be used in conjunction with routeRepresentation=none */
    instructionsType?: "coded" | "text" | "tagged";
    /** The language parameter determines the language of the guidance messages. It does not affect proper nouns (the names of streets, plazas, etc.) It has no effect when instructionsType=coded. Allowed values are (a subset of) the IETF language tags described */
    language?: string;
    /** Re-order the route waypoints using a fast heuristic algorithm to reduce the route length. Yields best results when used in conjunction with routeType _shortest_. Notice that origin and destination are excluded from the optimized waypoint indices. To include origin and destination in the response, please increase all the indices by 1 to account for the origin, and then add the destination as the final index. Possible values are true or false. True computes a better order if possible, but is not allowed to be used in conjunction with maxAlternatives value greater than 0 or in conjunction with circle waypoints. False will use the locations in the given order and not allowed to be used in conjunction with routeRepresentation _none_. */
    computeBestOrder?: boolean;
    /** Specifies the representation of the set of routes provided as response. This parameter value can only be used in conjunction with computeBestOrder=true. */
    routeRepresentation?: "polyline" | "summaryOnly" | "none";
    /** Specifies whether to return additional travel times using different types of traffic information (none, historic, live) as well as the default best-estimate travel time. */
    computeTravelTimeFor?: "none" | "all";
    /** The directional heading of the vehicle in degrees starting at true North and continuing in clockwise direction. North is 0 degrees, east is 90 degrees, south is 180 degrees, west is 270 degrees. Possible values 0-359 */
    vehicleHeading?: number;
    /** Specifies which data should be reported for diagnosis purposes. The only possible value is _effectiveSettings_. Reports the effective parameters or data used when calling the API. In the case of defaulted parameters the default will be reflected where the parameter was not specified by the caller. */
    report?: "effectiveSettings";
    /** Specifies which of the section types is reported in the route response. <br><br>For example if sectionType = pedestrian the sections which are suited for pedestrians only are returned. Multiple types can be used. The default sectionType refers to the travelMode input. By default travelMode is set to car */
    sectionType?: "carTrain" | "country" | "ferry" | "motorway" | "pedestrian" | "tollRoad" | "tollVignette" | "traffic" | "travelMode" | "tunnel" | "carpool" | "urban";
    /** The date and time of arrival at the destination point. It must be specified as a dateTime. When a time zone offset is not specified it will be assumed to be that of the destination point. The arriveAt value must be in the future. The arriveAt parameter cannot be used in conjunction with departAt, minDeviationDistance or minDeviationTime. */
    arriveAt?: Date | string;
    /** The date and time of departure from the origin point. Departure times apart from now must be specified as a dateTime. When a time zone offset is not specified, it will be assumed to be that of the origin point. The departAt value must be in the future in the date-time format (1996-12-19T16:39:57-08:00). */
    departAt?: Date | string;
    /** Weight per axle of the vehicle in kg. A value of 0 means that weight restrictions per axle are not considered. */
    vehicleAxleWeight?: number;
    /** Length of the vehicle in meters. A value of 0 means that length restrictions are not considered. */
    vehicleLength?: number;
    /** Height of the vehicle in meters. A value of 0 means that height restrictions are not considered. */
    vehicleHeight?: number;
    /** Width of the vehicle in meters. A value of 0 means that width restrictions are not considered. */
    vehicleWidth?: number;
    /**
     * Maximum speed of the vehicle in km/hour. The max speed in the vehicle profile is used to check whether a vehicle is allowed on motorways.
     *
     * * A value of 0 means that an appropriate value for the vehicle will be determined and applied during route planning.
     *
     * * A non-zero value may be overridden during route planning. For example, the current traffic flow is 60 km/hour. If the vehicle  maximum speed is set to 50 km/hour, the routing engine will consider 60 km/hour as this is the current situation.  If the maximum speed of the vehicle is provided as 80 km/hour but the current traffic flow is 60 km/hour, then routing engine will again use 60 km/hour.
     */
    vehicleMaxSpeed?: number;
    /**
     * Weight of the vehicle in kilograms.
     *
     * * It is mandatory if any of the *Efficiency parameters are set.
     *
     * * It must be strictly positive when used in the context of the Consumption Model. Weight restrictions are considered.
     *
     * * If no detailed **Consumption Model** is specified and the value of **vehicleWeight** is non-zero, then weight restrictions are considered.
     *
     * * In all other cases, this parameter is ignored.
     *
     * Sensible Values : for **Combustion Model** : 1600, for **Electric Model** : 1900
     */
    vehicleWeight?: number;
    /** Whether the vehicle is used for commercial purposes. Commercial vehicles may not be allowed to drive on some roads. */
    vehicleCommercial?: boolean;
    /** Level of turns for thrilling route. This parameter can only be used in conjunction with `routeType`=thrilling. */
    windingness?: "low" | "normal" | "high";
    /** Degree of hilliness for thrilling route. This parameter can only be used in conjunction with `routeType`=thrilling. */
    hilliness?: "low" | "normal" | "high";
    /** The mode of travel for the requested route. If not defined, default is 'car'. Note that the requested travelMode may not be available for the entire route. Where the requested travelMode is not available for a particular section, the travelMode element of the response for that section will be "other". Note that travel modes bus, motorcycle, taxi and van are BETA functionality. Full restriction data is not available in all areas. In **calculateReachableRange** requests, the values bicycle and pedestrian must not be used. */
    travelMode?: "car" | "truck" | "taxi" | "bus" | "van" | "motorcycle" | "bicycle" | "pedestrian";
    /** Specifies something that the route calculation should try to avoid when determining the route. Can be specified multiple times in one request, for example, '&avoid=motorways&avoid=tollRoads&avoid=ferries'. In calculateReachableRange requests, the value alreadyUsedRoads must not be used. */
    avoid?: Array<"tollRoads" | "motorways" | "ferries" | "unpavedRoads" | "carpools" | "alreadyUsedRoads" | "borderCrossings">;
    /**
     * Possible values:
     *   * true - Do consider all available traffic information during routing
     *   * false - Ignore current traffic data during routing. Note that although the current traffic data is ignored
     *   during routing, the effect of historic traffic on effective road speeds is still incorporated.
     */
    traffic?: boolean;
    /** The type of route requested. */
    routeType?: "fastest" | "shortest" | "eco" | "thrilling";
    /** Types of cargo that may be classified as hazardous materials and restricted from some roads. Available vehicleLoadType values are US Hazmat classes 1 through 9, plus generic classifications for use in other countries. Values beginning with USHazmat are for US routing while otherHazmat should be used for all other countries. vehicleLoadType can be specified multiple times. This parameter is currently only considered for travelMode=truck. */
    vehicleLoadType?: "USHazmatClass1" | "USHazmatClass2" | "USHazmatClass3" | "USHazmatClass4" | "USHazmatClass5" | "USHazmatClass6" | "USHazmatClass7" | "USHazmatClass8" | "USHazmatClass9" | "otherHazmatExplosive" | "otherHazmatGeneral" | "otherHazmatHarmfulToWater";
    /** Engine type of the vehicle. When a detailed Consumption Model is specified, it must be consistent with the value of **vehicleEngineType**. */
    vehicleEngineType?: "combustion" | "electric";
    /**
     *
     * Specifies the speed-dependent component of consumption.
     *
     * Provided as an unordered list of colon-delimited speed & consumption-rate pairs. The list defines points on a consumption curve. Consumption rates for speeds not in the list are found as follows:
     *
     *  * by linear interpolation, if the given speed lies in between two speeds in the list
     *
     *  * by linear extrapolation otherwise, assuming a constant (Consumption/Speed) determined by the nearest two points in the list
     *
     * The list must contain between 1 and 25 points (inclusive), and may not contain duplicate points for the same speed. If it only contains a single point, then the consumption rate of that point is used without further processing.
     *
     * Consumption specified for the largest speed must be greater than or equal to that of the penultimate largest speed. This ensures that extrapolation does not lead to negative consumption rates.
     *
     * Similarly, consumption values specified for the two smallest speeds in the list cannot lead to a negative consumption rate for any smaller speed.
     *
     * The valid range for the consumption values(expressed in l/100km) is between 0.01 and 100000.0.
     *
     * Sensible Values : 50,6.3:130,11.5
     *
     * **Note** : This parameter is required for **The Combustion Consumption Model**.
     */
    constantSpeedConsumptionInLitersPerHundredkm?: string;
    /**
     * Specifies the current supply of fuel in liters.
     *
     * Sensible Values : 55
     */
    currentFuelInLiters?: number;
    /**
     * Specifies the amount of fuel consumed for sustaining auxiliary systems of the vehicle, in liters per hour.
     *
     * It can be used to specify consumption due to devices and systems such as AC systems, radio, heating, etc.
     *
     * Sensible Values : 0.2
     */
    auxiliaryPowerInLitersPerHour?: number;
    /**
     * Specifies the amount of chemical energy stored in one liter of fuel in megajoules (MJ). It is used in conjunction with the ***Efficiency** parameters for conversions between saved or consumed energy and fuel. For example, energy density is 34.2 MJ/l for gasoline, and 35.8 MJ/l for Diesel fuel.
     *
     * This parameter is required if any ***Efficiency** parameter is set.
     *
     * Sensible Values : 34.2
     */
    fuelEnergyDensityInMJoulesPerLiter?: number;
    /**
     * Specifies the efficiency of converting chemical energy stored in fuel to kinetic energy when the vehicle accelerates _(i.e. KineticEnergyGained/ChemicalEnergyConsumed). ChemicalEnergyConsumed_ is obtained by converting consumed fuel to chemical energy using **fuelEnergyDensityInMJoulesPerLiter**.
     *
     * Must be paired with **decelerationEfficiency**.
     *
     * The range of values allowed are 0.0 to 1/**decelerationEfficiency**.
     *
     * Sensible Values : for **Combustion Model** : 0.33, for **Electric Model** : 0.66
     */
    accelerationEfficiency?: number;
    /**
     * Specifies the efficiency of converting kinetic energy to saved (not consumed) fuel when the vehicle decelerates _(i.e. ChemicalEnergySaved/KineticEnergyLost). ChemicalEnergySaved_ is obtained by converting saved (not consumed) fuel to energy using **fuelEnergyDensityInMJoulesPerLiter**.
     *
     * Must be paired with **accelerationEfficiency**.
     *
     * The range of values allowed are 0.0 to 1/**accelerationEfficiency**.
     *
     * Sensible Values : for **Combustion Model** : 0.83, for **Electric Model** : 0.91
     */
    decelerationEfficiency?: number;
    /**
     * Specifies the efficiency of converting chemical energy stored in fuel to potential energy when the vehicle gains elevation _(i.e. PotentialEnergyGained/ChemicalEnergyConsumed). ChemicalEnergyConsumed_ is obtained by converting consumed fuel to chemical energy using **fuelEnergyDensityInMJoulesPerLiter**.
     *
     * Must be paired with **downhillEfficiency**.
     *
     * The range of values allowed are 0.0 to 1/**downhillEfficiency**.
     *
     * Sensible Values : for **Combustion Model** : 0.27, for **Electric Model** : 0.74
     */
    uphillEfficiency?: number;
    /**
     * Specifies the efficiency of converting potential energy to saved (not consumed) fuel when the vehicle loses elevation _(i.e. ChemicalEnergySaved/PotentialEnergyLost). ChemicalEnergySaved_ is obtained by converting saved (not consumed) fuel to energy using **fuelEnergyDensityInMJoulesPerLiter**.
     *
     * Must be paired with **uphillEfficiency**.
     *
     * The range of values allowed are 0.0 to 1/**uphillEfficiency**.
     *
     * Sensible Values : for **Combustion Model** : 0.51, for **Electric Model** : 0.73
     */
    downhillEfficiency?: number;
    /**
     * Specifies the speed-dependent component of consumption.
     *
     * Provided as an unordered list of speed/consumption-rate pairs. The list defines points on a consumption curve. Consumption rates for speeds not in the list are found as follows:
     *
     * * by linear interpolation, if the given speed lies in between two speeds in the list
     *
     * * by linear extrapolation otherwise, assuming a constant (Consumption/Speed) determined by the nearest two points in the list
     *
     * The list must contain between 1 and 25 points (inclusive), and may not contain duplicate points for the same speed. If it only contains a single point, then the consumption rate of that point is used without further processing.
     *
     * Consumption specified for the largest speed must be greater than or equal to that of the penultimate largest speed. This ensures that extrapolation does not lead to negative consumption rates.
     *
     * Similarly, consumption values specified for the two smallest speeds in the list cannot lead to a negative consumption rate for any smaller  speed.
     *
     * The valid range for the consumption values(expressed in kWh/100km) is between 0.01 and 100000.0.
     *
     * Sensible Values : 50,8.2:130,21.3
     *
     * This parameter is required for **Electric consumption model**.
     */
    constantSpeedConsumptionInkWhPerHundredkm?: string;
    /**
     * Specifies the current electric energy supply in kilowatt hours (kWh).
     *
     * This parameter co-exists with **maxChargeInkWh** parameter.
     *
     * The range of values allowed are 0.0 to **maxChargeInkWh**.
     *
     * Sensible Values : 43
     */
    currentChargeInkWh?: number;
    /**
     * Specifies the maximum electric energy supply in kilowatt hours (kWh) that may be stored in the vehicle's battery.
     *
     * This parameter co-exists with **currentChargeInkWh** parameter.
     *
     * Minimum value has to be greater than or equal to **currentChargeInkWh**.
     *
     * Sensible Values : 85
     */
    maxChargeInkWh?: number;
    /**
     * Specifies the amount of power consumed for sustaining auxiliary systems, in kilowatts (kW).
     *
     * It can be used to specify consumption due to devices and systems such as AC systems, radio, heating, etc.
     *
     * Sensible Values : 1.7
     */
    auxiliaryPowerInkW?: number;
}

/**
 * **Applies to**: see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
 *
 * If the Matrix Route request was accepted successfully, the Location header in the response contains the URL to download the results of the request. This status URI looks like the following:
 *
 *   ```
 *     GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
 *   ```
 *
 *
 * 4. Client issues a GET request on the download URL obtained in Step 3 to download the results
 *
 * ### Download Sync Results
 * When you make a POST request for Route Matrix Sync API, the service returns 200 response code for successful request and a response array. The response body will contain the data and there will be no possibility to retrieve the results later.
 *
 * ### Download Async Results
 * When a request issues a `202 Accepted` response, the request is being processed using our async pipeline. You will be given a URL to check the progress of your  async request in the location header of the response. This status URI looks like the following:
 * ```
 *   GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
 * ```
 *
 * The URL provided by the location header will return the following responses when a `GET` request is issued.
 *
 *   > HTTP `202 Accepted` - Matrix request was accepted but is still being processed. Please try again in some time.
 *
 *   > HTTP `200 OK` - Matrix request successfully processed. The response body contains all of the results.
 */
export declare interface RouteGetRouteMatrix200Response extends HttpResponse {
    status: "200";
    body: RouteMatrixResultOutput;
}

export declare interface RouteGetRouteMatrix202Headers {
    /** New URL to check for the results of the long running process. */
    location?: string;
}

/**
 * **Applies to**: see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
 *
 * If the Matrix Route request was accepted successfully, the Location header in the response contains the URL to download the results of the request. This status URI looks like the following:
 *
 *   ```
 *     GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
 *   ```
 *
 *
 * 4. Client issues a GET request on the download URL obtained in Step 3 to download the results
 *
 * ### Download Sync Results
 * When you make a POST request for Route Matrix Sync API, the service returns 200 response code for successful request and a response array. The response body will contain the data and there will be no possibility to retrieve the results later.
 *
 * ### Download Async Results
 * When a request issues a `202 Accepted` response, the request is being processed using our async pipeline. You will be given a URL to check the progress of your  async request in the location header of the response. This status URI looks like the following:
 * ```
 *   GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
 * ```
 *
 * The URL provided by the location header will return the following responses when a `GET` request is issued.
 *
 *   > HTTP `202 Accepted` - Matrix request was accepted but is still being processed. Please try again in some time.
 *
 *   > HTTP `200 OK` - Matrix request successfully processed. The response body contains all of the results.
 */
export declare interface RouteGetRouteMatrix202Response extends HttpResponse {
    status: "202";
    body: Record<string, unknown>;
    headers: RawHttpHeaders & RouteGetRouteMatrix202Headers;
}

export declare type RouteGetRouteMatrixParameters = RequestParameters;

/**
 * __Route Range (Isochrone) API__
 *
 *
 * **Applies to**: see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
 *
 * This service will calculate a set of locations that can be reached from the origin point based on fuel, energy,  time or distance budget that is specified. A polygon boundary (or Isochrone) is returned in a counterclockwise  orientation as well as the precise polygon center which was the result of the origin point.
 *
 * The returned polygon can be used for further processing such as  [Search Inside Geometry](https://docs.microsoft.com/rest/api/maps/search/postsearchinsidegeometry) to  search for POIs within the provided Isochrone.
 */
export declare interface RouteGetRouteRange200Response extends HttpResponse {
    status: "200";
    body: RouteRangeResultOutput;
}

/**
 * __Route Range (Isochrone) API__
 *
 *
 * **Applies to**: see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
 *
 * This service will calculate a set of locations that can be reached from the origin point based on fuel, energy,  time or distance budget that is specified. A polygon boundary (or Isochrone) is returned in a counterclockwise  orientation as well as the precise polygon center which was the result of the origin point.
 *
 * The returned polygon can be used for further processing such as  [Search Inside Geometry](https://docs.microsoft.com/rest/api/maps/search/postsearchinsidegeometry) to  search for POIs within the provided Isochrone.
 */
export declare interface RouteGetRouteRangeDefaultResponse extends HttpResponse {
    status: string;
    body: ErrorResponseOutput;
}

export declare type RouteGetRouteRangeParameters = RouteGetRouteRangeQueryParam & RequestParameters;

export declare interface RouteGetRouteRangeQueryParam {
    queryParameters: RouteGetRouteRangeQueryParamProperties;
}

export declare interface RouteGetRouteRangeQueryParamProperties {
    /** The Coordinate from which the range calculation should start. */
    query: Array<number>;
    /** Fuel budget in liters that determines maximal range which can be travelled using the specified Combustion Consumption Model.<br> When fuelBudgetInLiters is used, it is mandatory to specify a detailed  Combustion Consumption Model.<br> Exactly one budget (fuelBudgetInLiters, energyBudgetInkWh, timeBudgetInSec, or distanceBudgetInMeters) must be used. */
    fuelBudgetInLiters?: number;
    /** Electric energy budget in kilowatt hours (kWh) that determines maximal range which can be travelled using the specified Electric Consumption Model.<br> When energyBudgetInkWh is used, it is mandatory to specify a detailed Electric Consumption Model.<br> Exactly one budget (fuelBudgetInLiters, energyBudgetInkWh, timeBudgetInSec, or distanceBudgetInMeters) must be used. */
    energyBudgetInkWh?: number;
    /** Time budget in seconds that determines maximal range which can be travelled using driving time. The Consumption Model will only affect the range when routeType is eco.<br> Exactly one budget (fuelBudgetInLiters, energyBudgetInkWh, timeBudgetInSec, or distanceBudgetInMeters) must be used. */
    timeBudgetInSec?: number;
    /** Distance budget in meters that determines maximal range which can be travelled using driving distance.  The Consumption Model will only affect the range when routeType is eco.<br> Exactly one budget (fuelBudgetInLiters, energyBudgetInkWh, timeBudgetInSec, or distanceBudgetInMeters) must be used. */
    distanceBudgetInMeters?: number;
    /** The date and time of departure from the origin point. Departure times apart from now must be specified as a dateTime. When a time zone offset is not specified, it will be assumed to be that of the origin point. The departAt value must be in the future in the date-time format (1996-12-19T16:39:57-08:00). */
    departAt?: Date | string;
    /** The type of route requested. */
    routeType?: "fastest" | "shortest" | "eco" | "thrilling";
    /**
     * Possible values:
     *   * true - Do consider all available traffic information during routing
     *   * false - Ignore current traffic data during routing. Note that although the current traffic data is ignored
     *   during routing, the effect of historic traffic on effective road speeds is still incorporated.
     */
    traffic?: boolean;
    /** Specifies something that the route calculation should try to avoid when determining the route. Can be specified multiple times in one request, for example, '&avoid=motorways&avoid=tollRoads&avoid=ferries'. In calculateReachableRange requests, the value alreadyUsedRoads must not be used. */
    avoid?: Array<"tollRoads" | "motorways" | "ferries" | "unpavedRoads" | "carpools" | "alreadyUsedRoads" | "borderCrossings">;
    /** The mode of travel for the requested route. If not defined, default is 'car'. Note that the requested travelMode may not be available for the entire route. Where the requested travelMode is not available for a particular section, the travelMode element of the response for that section will be "other". Note that travel modes bus, motorcycle, taxi and van are BETA functionality. Full restriction data is not available in all areas. In **calculateReachableRange** requests, the values bicycle and pedestrian must not be used. */
    travelMode?: "car" | "truck" | "taxi" | "bus" | "van" | "motorcycle" | "bicycle" | "pedestrian";
    /** Degree of hilliness for thrilling route. This parameter can only be used in conjunction with `routeType`=thrilling. */
    hilliness?: "low" | "normal" | "high";
    /** Level of turns for thrilling route. This parameter can only be used in conjunction with `routeType`=thrilling. */
    windingness?: "low" | "normal" | "high";
    /** Weight per axle of the vehicle in kg. A value of 0 means that weight restrictions per axle are not considered. */
    vehicleAxleWeight?: number;
    /** Width of the vehicle in meters. A value of 0 means that width restrictions are not considered. */
    vehicleWidth?: number;
    /** Height of the vehicle in meters. A value of 0 means that height restrictions are not considered. */
    vehicleHeight?: number;
    /** Length of the vehicle in meters. A value of 0 means that length restrictions are not considered. */
    vehicleLength?: number;
    /**
     * Maximum speed of the vehicle in km/hour. The max speed in the vehicle profile is used to check whether a vehicle is allowed on motorways.
     *
     * * A value of 0 means that an appropriate value for the vehicle will be determined and applied during route planning.
     *
     * * A non-zero value may be overridden during route planning. For example, the current traffic flow is 60 km/hour. If the vehicle  maximum speed is set to 50 km/hour, the routing engine will consider 60 km/hour as this is the current situation.  If the maximum speed of the vehicle is provided as 80 km/hour but the current traffic flow is 60 km/hour, then routing engine will again use 60 km/hour.
     */
    vehicleMaxSpeed?: number;
    /**
     * Weight of the vehicle in kilograms.
     *
     * * It is mandatory if any of the *Efficiency parameters are set.
     *
     * * It must be strictly positive when used in the context of the Consumption Model. Weight restrictions are considered.
     *
     * * If no detailed **Consumption Model** is specified and the value of **vehicleWeight** is non-zero, then weight restrictions are considered.
     *
     * * In all other cases, this parameter is ignored.
     *
     * Sensible Values : for **Combustion Model** : 1600, for **Electric Model** : 1900
     */
    vehicleWeight?: number;
    /** Whether the vehicle is used for commercial purposes. Commercial vehicles may not be allowed to drive on some roads. */
    vehicleCommercial?: boolean;
    /** Types of cargo that may be classified as hazardous materials and restricted from some roads. Available vehicleLoadType values are US Hazmat classes 1 through 9, plus generic classifications for use in other countries. Values beginning with USHazmat are for US routing while otherHazmat should be used for all other countries. vehicleLoadType can be specified multiple times. This parameter is currently only considered for travelMode=truck. */
    vehicleLoadType?: "USHazmatClass1" | "USHazmatClass2" | "USHazmatClass3" | "USHazmatClass4" | "USHazmatClass5" | "USHazmatClass6" | "USHazmatClass7" | "USHazmatClass8" | "USHazmatClass9" | "otherHazmatExplosive" | "otherHazmatGeneral" | "otherHazmatHarmfulToWater";
    /** Engine type of the vehicle. When a detailed Consumption Model is specified, it must be consistent with the value of **vehicleEngineType**. */
    vehicleEngineType?: "combustion" | "electric";
    /**
     *
     * Specifies the speed-dependent component of consumption.
     *
     * Provided as an unordered list of colon-delimited speed & consumption-rate pairs. The list defines points on a consumption curve. Consumption rates for speeds not in the list are found as follows:
     *
     *  * by linear interpolation, if the given speed lies in between two speeds in the list
     *
     *  * by linear extrapolation otherwise, assuming a constant (Consumption/Speed) determined by the nearest two points in the list
     *
     * The list must contain between 1 and 25 points (inclusive), and may not contain duplicate points for the same speed. If it only contains a single point, then the consumption rate of that point is used without further processing.
     *
     * Consumption specified for the largest speed must be greater than or equal to that of the penultimate largest speed. This ensures that extrapolation does not lead to negative consumption rates.
     *
     * Similarly, consumption values specified for the two smallest speeds in the list cannot lead to a negative consumption rate for any smaller speed.
     *
     * The valid range for the consumption values(expressed in l/100km) is between 0.01 and 100000.0.
     *
     * Sensible Values : 50,6.3:130,11.5
     *
     * **Note** : This parameter is required for **The Combustion Consumption Model**.
     */
    constantSpeedConsumptionInLitersPerHundredkm?: string;
    /**
     * Specifies the current supply of fuel in liters.
     *
     * Sensible Values : 55
     */
    currentFuelInLiters?: number;
    /**
     * Specifies the amount of fuel consumed for sustaining auxiliary systems of the vehicle, in liters per hour.
     *
     * It can be used to specify consumption due to devices and systems such as AC systems, radio, heating, etc.
     *
     * Sensible Values : 0.2
     */
    auxiliaryPowerInLitersPerHour?: number;
    /**
     * Specifies the amount of chemical energy stored in one liter of fuel in megajoules (MJ). It is used in conjunction with the ***Efficiency** parameters for conversions between saved or consumed energy and fuel. For example, energy density is 34.2 MJ/l for gasoline, and 35.8 MJ/l for Diesel fuel.
     *
     * This parameter is required if any ***Efficiency** parameter is set.
     *
     * Sensible Values : 34.2
     */
    fuelEnergyDensityInMJoulesPerLiter?: number;
    /**
     * Specifies the efficiency of converting chemical energy stored in fuel to kinetic energy when the vehicle accelerates _(i.e. KineticEnergyGained/ChemicalEnergyConsumed). ChemicalEnergyConsumed_ is obtained by converting consumed fuel to chemical energy using **fuelEnergyDensityInMJoulesPerLiter**.
     *
     * Must be paired with **decelerationEfficiency**.
     *
     * The range of values allowed are 0.0 to 1/**decelerationEfficiency**.
     *
     * Sensible Values : for **Combustion Model** : 0.33, for **Electric Model** : 0.66
     */
    accelerationEfficiency?: number;
    /**
     * Specifies the efficiency of converting kinetic energy to saved (not consumed) fuel when the vehicle decelerates _(i.e. ChemicalEnergySaved/KineticEnergyLost). ChemicalEnergySaved_ is obtained by converting saved (not consumed) fuel to energy using **fuelEnergyDensityInMJoulesPerLiter**.
     *
     * Must be paired with **accelerationEfficiency**.
     *
     * The range of values allowed are 0.0 to 1/**accelerationEfficiency**.
     *
     * Sensible Values : for **Combustion Model** : 0.83, for **Electric Model** : 0.91
     */
    decelerationEfficiency?: number;
    /**
     * Specifies the efficiency of converting chemical energy stored in fuel to potential energy when the vehicle gains elevation _(i.e. PotentialEnergyGained/ChemicalEnergyConsumed). ChemicalEnergyConsumed_ is obtained by converting consumed fuel to chemical energy using **fuelEnergyDensityInMJoulesPerLiter**.
     *
     * Must be paired with **downhillEfficiency**.
     *
     * The range of values allowed are 0.0 to 1/**downhillEfficiency**.
     *
     * Sensible Values : for **Combustion Model** : 0.27, for **Electric Model** : 0.74
     */
    uphillEfficiency?: number;
    /**
     * Specifies the efficiency of converting potential energy to saved (not consumed) fuel when the vehicle loses elevation _(i.e. ChemicalEnergySaved/PotentialEnergyLost). ChemicalEnergySaved_ is obtained by converting saved (not consumed) fuel to energy using **fuelEnergyDensityInMJoulesPerLiter**.
     *
     * Must be paired with **uphillEfficiency**.
     *
     * The range of values allowed are 0.0 to 1/**uphillEfficiency**.
     *
     * Sensible Values : for **Combustion Model** : 0.51, for **Electric Model** : 0.73
     */
    downhillEfficiency?: number;
    /**
     * Specifies the speed-dependent component of consumption.
     *
     * Provided as an unordered list of speed/consumption-rate pairs. The list defines points on a consumption curve. Consumption rates for speeds not in the list are found as follows:
     *
     * * by linear interpolation, if the given speed lies in between two speeds in the list
     *
     * * by linear extrapolation otherwise, assuming a constant (Consumption/Speed) determined by the nearest two points in the list
     *
     * The list must contain between 1 and 25 points (inclusive), and may not contain duplicate points for the same speed. If it only contains a single point, then the consumption rate of that point is used without further processing.
     *
     * Consumption specified for the largest speed must be greater than or equal to that of the penultimate largest speed. This ensures that extrapolation does not lead to negative consumption rates.
     *
     * Similarly, consumption values specified for the two smallest speeds in the list cannot lead to a negative consumption rate for any smaller  speed.
     *
     * The valid range for the consumption values(expressed in kWh/100km) is between 0.01 and 100000.0.
     *
     * Sensible Values : 50,8.2:130,21.3
     *
     * This parameter is required for **Electric consumption model**.
     */
    constantSpeedConsumptionInkWhPerHundredkm?: string;
    /**
     * Specifies the current electric energy supply in kilowatt hours (kWh).
     *
     * This parameter co-exists with **maxChargeInkWh** parameter.
     *
     * The range of values allowed are 0.0 to **maxChargeInkWh**.
     *
     * Sensible Values : 43
     */
    currentChargeInkWh?: number;
    /**
     * Specifies the maximum electric energy supply in kilowatt hours (kWh) that may be stored in the vehicle's battery.
     *
     * This parameter co-exists with **currentChargeInkWh** parameter.
     *
     * Minimum value has to be greater than or equal to **currentChargeInkWh**.
     *
     * Sensible Values : 85
     */
    maxChargeInkWh?: number;
    /**
     * Specifies the amount of power consumed for sustaining auxiliary systems, in kilowatts (kW).
     *
     * It can be used to specify consumption due to devices and systems such as AC systems, radio, heating, etc.
     *
     * Sensible Values : 1.7
     */
    auxiliaryPowerInkW?: number;
}

/** Contains guidance related elements. This field is present only when guidance was requested and is available. */
export declare interface RouteGuidanceOutput {
    /** A list of instructions describing maneuvers. */
    instructions: Array<RouteInstructionOutput>;
    /** Groups a sequence of instruction elements which are related to each other. */
    instructionGroups: Array<RouteInstructionGroupOutput>;
}

/** Groups a sequence of instruction elements which are related to each other. The sequence range is constrained with firstInstructionIndex and lastInstructionIndex. When human-readable text messages are requested for guidance (instructionType=text or tagged), then the instructionGroup has a summary message returned when available. */
export declare interface RouteInstructionGroupOutput {
    /** Index of the first instruction in the instructions and belonging to this group. */
    firstInstructionIndex?: number;
    /** Index of the last instruction in the instructions and belonging to this group. */
    lastInstructionIndex?: number;
    /** Length of the group. */
    groupLengthInMeters?: number;
    /** Summary message when human-readable text messages are requested for guidance (instructionType=text or tagged). */
    groupMessage?: string;
}

/** A set of attributes describing a maneuver, e.g. 'Turn right', 'Keep left', 'Take the ferry', 'Take the motorway', 'Arrive'. */
export declare interface RouteInstructionOutput {
    /** Distance from the start of the route to the point of the instruction. */
    routeOffsetInMeters?: number;
    /** Estimated travel time up to the point corresponding to routeOffsetInMeters. */
    travelTimeInSeconds?: number;
    /** A location represented as a latitude and longitude. */
    point?: LatLongPairOutput;
    /** The index of the point in the list of polyline "points" corresponding to the point of the instruction. */
    pointIndex?: number;
    /** Type of the instruction, e.g., turn or change of road form. */
    instructionType?: "TURN" | "ROAD_CHANGE" | "LOCATION_DEPARTURE" | "LOCATION_ARRIVAL" | "DIRECTION_INFO" | "LOCATION_WAYPOINT";
    /** The road number(s) of the next significant road segment(s) after the maneuver, or of the road(s) to be followed. Example: ["E34", "N205"] */
    roadNumbers?: Array<string>;
    /** The number(s) of a highway exit taken by the current maneuver. If an exit has multiple exit numbers, they will be separated by "," and possibly aggregated by "-", e.g., "10, 13-15". */
    exitNumber?: string;
    /** Street name of the next significant road segment after the maneuver, or of the street that should be followed. */
    street?: string;
    /** The text on a signpost which is most relevant to the maneuver, or to the direction that should be followed. */
    signpostText?: string;
    /** 3-character [ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html) alpha-3 country code. E.g. USA. */
    countryCode?: string;
    /** A subdivision (e.g., state) of the country, represented by the second part of an [ISO 3166-2](https://www.iso.org/standard/63546.html) code. This is only available for some countries like the US, Canada, and Mexico. */
    stateCode?: string;
    /** The type of the junction where the maneuver takes place. For larger roundabouts, two separate instructions are generated for entering and leaving the roundabout. */
    junctionType?: "REGULAR" | "ROUNDABOUT" | "BIFURCATION";
    /**
     * Indicates the direction of an instruction. If junctionType indicates a turn instruction:
     *
     *   * 180 = U-turn
     *   * [-179, -1] = Left turn
     *   * 0 = Straight on (a '0 degree' turn)
     *   * [1, 179] = Right turn
     *
     * If junctionType indicates a bifurcation instruction:
     *
     *   * <0 - keep left
     *   * \>0 - keep right
     */
    turnAngleInDecimalDegrees?: number;
    /** This indicates which exit to take at a roundabout. */
    roundaboutExitNumber?: string;
    /** It is possible to optionally combine the instruction with the next one. This can be used to build messages like "Turn left and then turn right". */
    possibleCombineWithNext?: boolean;
    /** Indicates left-hand vs. right-hand side driving at the point of the maneuver. */
    drivingSide?: "LEFT" | "RIGHT";
    /** A code identifying the maneuver. */
    maneuver?: "ARRIVE" | "ARRIVE_LEFT" | "ARRIVE_RIGHT" | "DEPART" | "STRAIGHT" | "KEEP_RIGHT" | "BEAR_RIGHT" | "TURN_RIGHT" | "SHARP_RIGHT" | "KEEP_LEFT" | "BEAR_LEFT" | "TURN_LEFT" | "SHARP_LEFT" | "MAKE_UTURN" | "ENTER_MOTORWAY" | "ENTER_FREEWAY" | "ENTER_HIGHWAY" | "TAKE_EXIT" | "MOTORWAY_EXIT_LEFT" | "MOTORWAY_EXIT_RIGHT" | "TAKE_FERRY" | "ROUNDABOUT_CROSS" | "ROUNDABOUT_RIGHT" | "ROUNDABOUT_LEFT" | "ROUNDABOUT_BACK" | "TRY_MAKE_UTURN" | "FOLLOW" | "SWITCH_PARALLEL_ROAD" | "SWITCH_MAIN_ROAD" | "ENTRANCE_RAMP" | "WAYPOINT_LEFT" | "WAYPOINT_RIGHT" | "WAYPOINT_REACHED";
    /** A human-readable message for the maneuver. */
    message?: string;
    /**
     * A human-readable message for the maneuver combined with the message from the next instruction. Sometimes it is possible to combine two successive instructions into a single instruction making it easier to follow. When this is the case the possibleCombineWithNext flag will be true. For example:
     *
     * ```
     * 10. Turn left onto Einsteinweg/A10/E22 towards Ring Amsterdam
     * 11. Follow Einsteinweg/A10/E22 towards Ring Amsterdam
     * ```
     *
     * The possibleCombineWithNext flag on instruction 10 is true. This indicates to the clients of coded guidance that it can be combined with instruction 11. The instructions will be combined automatically for clients requesting human-readable guidance. The combinedMessage field contains the combined message:
     *
     * ```
     * Turn left onto Einsteinweg/A10/E22 towards Ring Amsterdam
     * then follow Einsteinweg/A10/E22 towards Ring Amsterdam.
     * ```
     */
    combinedMessage?: string;
}

/** A description of a part of a route, comprised of a list of points. Each additional waypoint provided in the request will result in an additional leg in the returned route. */
export declare interface RouteLegOutput {
    /** Summary object */
    summary: RouteSummaryOutput;
    /** Points array */
    points: Array<LatLongPairOutput>;
}

/** Matrix result object */
export declare interface RouteMatrixOutput {
    /** StatusCode property for the current cell in the input matrix. */
    statusCode: number;
    /** Response object of the current cell in the input matrix. */
    response?: RouteMatrixResultResponseOutput;
}

/** An object with a matrix of coordinates. */
export declare interface RouteMatrixQuery {
    /** A valid `GeoJSON MultiPoint` geometry type. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1.3) for details. */
    origins: GeoJsonMultiPoint;
    /** A valid `GeoJSON MultiPoint` geometry type. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1.3) for details. */
    destinations: GeoJsonMultiPoint;
}

/** This object is returned from a successful Route Matrix call. For ex, if 2 origins and 3 destinations are provided, there are going to 2 arrays with 3 elements in each. Each element's content depends on the options provided in the query. */
export declare interface RouteMatrixResultOutput {
    /** Format Version property */
    formatVersion?: string;
    /** Results as a 2 dimensional array of route summaries. */
    matrix: Array<Array<RouteMatrixOutput>>;
    /** Summary object */
    summary: RouteMatrixSummaryOutput;
}

/** Response object of the current cell in the input matrix. */
export declare interface RouteMatrixResultResponseOutput {
    /** Summary object */
    routeSummary?: RouteSummaryOutput;
}

/** Summary object */
export declare interface RouteMatrixSummaryOutput {
    /** Number of successful routes in the response. */
    successfulRoutes: number;
    /** Total number of routes requested. Number of cells in the input matrix. */
    totalRoutes: number;
}

/** Optimized way point object. */
export declare interface RouteOptimizedWaypointOutput {
    /** Way point index provided by the user. */
    providedIndex: number;
    /** Optimized way point index from the system. */
    optimizedIndex: number;
}

export declare interface RouteOutput {
    /** Summary object */
    summary: RouteSummaryOutput;
    /** Legs array */
    legs: Array<RouteLegOutput>;
    /** Sections array */
    sections?: Array<RouteSectionOutput>;
    /** Contains guidance related elements. This field is present only when guidance was requested and is available. */
    guidance?: RouteGuidanceOutput;
}

/** Reachable Range */
export declare interface RouteRangeOutput {
    /** Center point of the reachable range */
    center: LatLongPairOutput;
    /** Polygon boundary of the reachable range represented as a list of points. */
    boundary: Array<LatLongPairOutput>;
}

/** This object is returned from a successful Route Reachable Range call */
export declare interface RouteRangeResultOutput {
    /** Format Version property */
    formatVersion?: string;
    /** Reachable Range */
    reachableRange: RouteRangeOutput;
    /** Reports the effective settings used in the current call. */
    report?: RouteReportOutput;
}

/** Reports the effective settings used in the current call. */
export declare interface RouteReportOutput {
    /** Effective parameters or data used when calling this Route API. */
    effectiveSettings: Array<EffectiveSettingOutput>;
}

/**
 * **Route Directions Batch API**
 *
 *
 * **Applies to**: see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
 *
 *
 *
 * The Route Directions Batch API sends batches of queries to [Route Directions API](https://docs.microsoft.com/rest/api/maps/route/getroutedirections) using just a single API call. You can call Route Directions Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to **700** queries and sync API up to **100** queries.
 * ### Submit Asynchronous Batch Request
 * The Asynchronous API is appropriate for processing big volumes of relatively complex route requests
 * - It allows the retrieval of results in a separate call (multiple downloads are possible).
 * - The asynchronous API is optimized for reliability and is not expected to run into a timeout.
 * - The number of batch items is limited to **700** for this API.
 *
 * When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the response header. This URL should be checked periodically until the response data or error information is available.
 * The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the expiration period.
 *
 * Please note that asynchronous batch request is a long-running request. Here's a typical sequence of operations:
 * 1. Client sends a Route Directions Batch `POST` request to Azure Maps
 * 2. The server will respond with one of the following:
 *
 *     > HTTP `202 Accepted` - Batch request has been accepted.
 *
 *     > HTTP `Error` - There was an error processing your Batch request. This could either be a `400 Bad Request` or any other `Error` status code.
 *
 * 3. If the batch request was accepted successfully, the `Location` header in the response contains the URL to download the results of the batch request.
 *     This status URI looks like following:
 *
 * ``` GET https://atlas.microsoft.com/route/directions/batch/{batch-id}?api-version=1.0 ```
 * Note:- Please remember to add AUTH information (subscription-key/azure_auth - See [Security](#security)) to the _status URI_ before running it. <br>
 * 4. Client issues a `GET` request on the _download URL_ obtained in Step 3 to download the batch results.
 *
 * ### POST Body for Batch Request
 * To send the _route directions_ queries you will use a `POST` request where the request body will contain the `batchItems` array in `json` format and the `Content-Type` header will be set to `application/json`. Here's a sample request body containing 3 _route directions_ queries:
 *
 *
 * ```json
 * {
 *     "batchItems": [
 *         { "query": "?query=47.620659,-122.348934:47.610101,-122.342015&travelMode=bicycle&routeType=eco&traffic=false" },
 *         { "query": "?query=40.759856,-73.985108:40.771136,-73.973506&travelMode=pedestrian&routeType=shortest" },
 *         { "query": "?query=48.923159,-122.557362:32.621279,-116.840362" }
 *     ]
 * }
 * ```
 *
 * A _route directions_ query in a batch is just a partial URL _without_ the protocol, base URL, path, api-version and subscription-key. It can accept any of the supported _route directions_ [URI parameters](https://docs.microsoft.com/rest/api/maps/route/getroutedirections#uri-parameters). The string values in the _route directions_ query must be properly escaped (e.g. " character should be escaped with \\ ) and it should also be properly URL-encoded.
 *
 *
 * The async API allows caller to batch up to **700** queries and sync API up to **100** queries, and the batch should contain at least **1** query.
 *
 *
 * ### Download Asynchronous Batch Results
 * To download the async batch results you will issue a `GET` request to the batch download endpoint. This _download URL_ can be obtained from the `Location` header of a successful `POST` batch request and looks like the following:
 *
 * ```
 * https://atlas.microsoft.com/route/directions/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
 * ```
 * Here's the typical sequence of operations for downloading the batch results:
 * 1. Client sends a `GET` request using the _download URL_.
 * 2. The server will respond with one of the following:
 *
 *     > HTTP `202 Accepted` - Batch request was accepted but is still being processed. Please try again in some time.
 *
 *     > HTTP `200 OK` - Batch request successfully processed. The response body contains all the batch results.
 *
 *
 *
 * ### Batch Response Model
 * The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the batch has finished processing, the response body contains the batch response. This batch response contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems` array which contains a response for each and every query in the batch request. The `batchItems` will contain the results in the exact same order the original queries were sent in the batch request. Each item in `batchItems` contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
 *
 *   - [`RouteDirections`](https://docs.microsoft.com/rest/api/maps/route/getroutedirections#routedirections) - If the query completed successfully.
 *
 *   - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
 *
 *
 * Here's a sample Batch Response with 1 _successful_ and 1 _failed_ result:
 *
 *
 * ```json
 * {
 *     "summary": {
 *         "successfulRequests": 1,
 *         "totalRequests": 2
 *     },
 *     "batchItems": [
 *         {
 *             "statusCode": 200,
 *             "response": {
 *                 "routes": [
 *                     {
 *                         "summary": {
 *                             "lengthInMeters": 1758,
 *                             "travelTimeInSeconds": 387,
 *                             "trafficDelayInSeconds": 0,
 *                             "departureTime": "2018-07-17T00:49:56+00:00",
 *                             "arrivalTime": "2018-07-17T00:56:22+00:00"
 *                         },
 *                         "legs": [
 *                             {
 *                                 "summary": {
 *                                     "lengthInMeters": 1758,
 *                                     "travelTimeInSeconds": 387,
 *                                     "trafficDelayInSeconds": 0,
 *                                     "departureTime": "2018-07-17T00:49:56+00:00",
 *                                     "arrivalTime": "2018-07-17T00:56:22+00:00"
 *                                 },
 *                                 "points": [
 *                                     {
 *                                         "latitude": 47.62094,
 *                                         "longitude": -122.34892
 *                                     },
 *                                     {
 *                                         "latitude": 47.62094,
 *                                         "longitude": -122.3485
 *                                     },
 *                                     {
 *                                         "latitude": 47.62095,
 *                                         "longitude": -122.3476
 *                                     }
 *                                 ]
 *                             }
 *                         ],
 *                         "sections": [
 *                             {
 *                                 "startPointIndex": 0,
 *                                 "endPointIndex": 40,
 *                                 "sectionType": "TRAVEL_MODE",
 *                                 "travelMode": "bicycle"
 *                             }
 *                         ]
 *                     }
 *                 ]
 *             }
 *         },
 *         {
 *             "statusCode": 400,
 *             "response":
 *             {
 *                 "error":
 *                 {
 *                     "code": "400 BadRequest",
 *                     "message": "Bad request: one or more parameters were incorrectly specified or are mutually exclusive."
 *                 }
 *             }
 *         }
 *     ]
 * }
 * ```
 */
export declare interface RouteRequestRouteDirectionsBatch200Response extends HttpResponse {
    status: "200";
    body: RouteDirectionsBatchResultOutput;
}

export declare interface RouteRequestRouteDirectionsBatch202Headers {
    /** New URL to check for the results of the long running process. */
    location?: string;
}

/**
 * **Route Directions Batch API**
 *
 *
 * **Applies to**: see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
 *
 *
 *
 * The Route Directions Batch API sends batches of queries to [Route Directions API](https://docs.microsoft.com/rest/api/maps/route/getroutedirections) using just a single API call. You can call Route Directions Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to **700** queries and sync API up to **100** queries.
 * ### Submit Asynchronous Batch Request
 * The Asynchronous API is appropriate for processing big volumes of relatively complex route requests
 * - It allows the retrieval of results in a separate call (multiple downloads are possible).
 * - The asynchronous API is optimized for reliability and is not expected to run into a timeout.
 * - The number of batch items is limited to **700** for this API.
 *
 * When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the response header. This URL should be checked periodically until the response data or error information is available.
 * The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the expiration period.
 *
 * Please note that asynchronous batch request is a long-running request. Here's a typical sequence of operations:
 * 1. Client sends a Route Directions Batch `POST` request to Azure Maps
 * 2. The server will respond with one of the following:
 *
 *     > HTTP `202 Accepted` - Batch request has been accepted.
 *
 *     > HTTP `Error` - There was an error processing your Batch request. This could either be a `400 Bad Request` or any other `Error` status code.
 *
 * 3. If the batch request was accepted successfully, the `Location` header in the response contains the URL to download the results of the batch request.
 *     This status URI looks like following:
 *
 * ``` GET https://atlas.microsoft.com/route/directions/batch/{batch-id}?api-version=1.0 ```
 * Note:- Please remember to add AUTH information (subscription-key/azure_auth - See [Security](#security)) to the _status URI_ before running it. <br>
 * 4. Client issues a `GET` request on the _download URL_ obtained in Step 3 to download the batch results.
 *
 * ### POST Body for Batch Request
 * To send the _route directions_ queries you will use a `POST` request where the request body will contain the `batchItems` array in `json` format and the `Content-Type` header will be set to `application/json`. Here's a sample request body containing 3 _route directions_ queries:
 *
 *
 * ```json
 * {
 *     "batchItems": [
 *         { "query": "?query=47.620659,-122.348934:47.610101,-122.342015&travelMode=bicycle&routeType=eco&traffic=false" },
 *         { "query": "?query=40.759856,-73.985108:40.771136,-73.973506&travelMode=pedestrian&routeType=shortest" },
 *         { "query": "?query=48.923159,-122.557362:32.621279,-116.840362" }
 *     ]
 * }
 * ```
 *
 * A _route directions_ query in a batch is just a partial URL _without_ the protocol, base URL, path, api-version and subscription-key. It can accept any of the supported _route directions_ [URI parameters](https://docs.microsoft.com/rest/api/maps/route/getroutedirections#uri-parameters). The string values in the _route directions_ query must be properly escaped (e.g. " character should be escaped with \\ ) and it should also be properly URL-encoded.
 *
 *
 * The async API allows caller to batch up to **700** queries and sync API up to **100** queries, and the batch should contain at least **1** query.
 *
 *
 * ### Download Asynchronous Batch Results
 * To download the async batch results you will issue a `GET` request to the batch download endpoint. This _download URL_ can be obtained from the `Location` header of a successful `POST` batch request and looks like the following:
 *
 * ```
 * https://atlas.microsoft.com/route/directions/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
 * ```
 * Here's the typical sequence of operations for downloading the batch results:
 * 1. Client sends a `GET` request using the _download URL_.
 * 2. The server will respond with one of the following:
 *
 *     > HTTP `202 Accepted` - Batch request was accepted but is still being processed. Please try again in some time.
 *
 *     > HTTP `200 OK` - Batch request successfully processed. The response body contains all the batch results.
 *
 *
 *
 * ### Batch Response Model
 * The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the batch has finished processing, the response body contains the batch response. This batch response contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems` array which contains a response for each and every query in the batch request. The `batchItems` will contain the results in the exact same order the original queries were sent in the batch request. Each item in `batchItems` contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
 *
 *   - [`RouteDirections`](https://docs.microsoft.com/rest/api/maps/route/getroutedirections#routedirections) - If the query completed successfully.
 *
 *   - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
 *
 *
 * Here's a sample Batch Response with 1 _successful_ and 1 _failed_ result:
 *
 *
 * ```json
 * {
 *     "summary": {
 *         "successfulRequests": 1,
 *         "totalRequests": 2
 *     },
 *     "batchItems": [
 *         {
 *             "statusCode": 200,
 *             "response": {
 *                 "routes": [
 *                     {
 *                         "summary": {
 *                             "lengthInMeters": 1758,
 *                             "travelTimeInSeconds": 387,
 *                             "trafficDelayInSeconds": 0,
 *                             "departureTime": "2018-07-17T00:49:56+00:00",
 *                             "arrivalTime": "2018-07-17T00:56:22+00:00"
 *                         },
 *                         "legs": [
 *                             {
 *                                 "summary": {
 *                                     "lengthInMeters": 1758,
 *                                     "travelTimeInSeconds": 387,
 *                                     "trafficDelayInSeconds": 0,
 *                                     "departureTime": "2018-07-17T00:49:56+00:00",
 *                                     "arrivalTime": "2018-07-17T00:56:22+00:00"
 *                                 },
 *                                 "points": [
 *                                     {
 *                                         "latitude": 47.62094,
 *                                         "longitude": -122.34892
 *                                     },
 *                                     {
 *                                         "latitude": 47.62094,
 *                                         "longitude": -122.3485
 *                                     },
 *                                     {
 *                                         "latitude": 47.62095,
 *                                         "longitude": -122.3476
 *                                     }
 *                                 ]
 *                             }
 *                         ],
 *                         "sections": [
 *                             {
 *                                 "startPointIndex": 0,
 *                                 "endPointIndex": 40,
 *                                 "sectionType": "TRAVEL_MODE",
 *                                 "travelMode": "bicycle"
 *                             }
 *                         ]
 *                     }
 *                 ]
 *             }
 *         },
 *         {
 *             "statusCode": 400,
 *             "response":
 *             {
 *                 "error":
 *                 {
 *                     "code": "400 BadRequest",
 *                     "message": "Bad request: one or more parameters were incorrectly specified or are mutually exclusive."
 *                 }
 *             }
 *         }
 *     ]
 * }
 * ```
 */
export declare interface RouteRequestRouteDirectionsBatch202Response extends HttpResponse {
    status: "202";
    body: Record<string, unknown>;
    headers: RawHttpHeaders & RouteRequestRouteDirectionsBatch202Headers;
}

export declare interface RouteRequestRouteDirectionsBatchBodyParam {
    /** The list of route directions queries/requests to process. The list can contain a max of 700 queries for async and 100 queries for sync version and must contain at least 1 query. */
    body: BatchRequest;
}

export declare interface RouteRequestRouteDirectionsBatchMediaTypesParam {
    /** Request content type */
    contentType?: "application/json";
}

export declare type RouteRequestRouteDirectionsBatchParameters = RouteRequestRouteDirectionsBatchMediaTypesParam & RouteRequestRouteDirectionsBatchBodyParam & RequestParameters;

/**
 * **Route Directions Batch API**
 *
 *
 * **Applies to**: see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
 *
 *
 *
 * The Route Directions Batch API sends batches of queries to [Route Directions API](https://docs.microsoft.com/rest/api/maps/route/getroutedirections) using just a single API call. You can call Route Directions Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to **700** queries and sync API up to **100** queries.
 * ### Submit Synchronous Batch Request
 * The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond as soon as the batch items are calculated and there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer than 60 seconds. The number of batch items is limited to **100** for this API.
 * ```
 * POST https://atlas.microsoft.com/route/directions/batch/sync/json?api-version=1.0&subscription-key={subscription-key}
 * ```
 * ### Batch Response Model
 * The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the batch has finished processing, the response body contains the batch response. This batch response contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems` array which contains a response for each and every query in the batch request. The `batchItems` will contain the results in the exact same order the original queries were sent in the batch request. Each item in `batchItems` contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
 *
 *   - [`RouteDirections`](https://docs.microsoft.com/rest/api/maps/route/getroutedirections#routedirections) - If the query completed successfully.
 *
 *   - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
 *
 *
 * Here's a sample Batch Response with 1 _successful_ and 1 _failed_ result:
 *
 *
 * ```json
 * {
 *     "summary": {
 *         "successfulRequests": 1,
 *         "totalRequests": 2
 *     },
 *     "batchItems": [
 *         {
 *             "statusCode": 200,
 *             "response": {
 *                 "routes": [
 *                     {
 *                         "summary": {
 *                             "lengthInMeters": 1758,
 *                             "travelTimeInSeconds": 387,
 *                             "trafficDelayInSeconds": 0,
 *                             "departureTime": "2018-07-17T00:49:56+00:00",
 *                             "arrivalTime": "2018-07-17T00:56:22+00:00"
 *                         },
 *                         "legs": [
 *                             {
 *                                 "summary": {
 *                                     "lengthInMeters": 1758,
 *                                     "travelTimeInSeconds": 387,
 *                                     "trafficDelayInSeconds": 0,
 *                                     "departureTime": "2018-07-17T00:49:56+00:00",
 *                                     "arrivalTime": "2018-07-17T00:56:22+00:00"
 *                                 },
 *                                 "points": [
 *                                     {
 *                                         "latitude": 47.62094,
 *                                         "longitude": -122.34892
 *                                     },
 *                                     {
 *                                         "latitude": 47.62094,
 *                                         "longitude": -122.3485
 *                                     },
 *                                     {
 *                                         "latitude": 47.62095,
 *                                         "longitude": -122.3476
 *                                     }
 *                                 ]
 *                             }
 *                         ],
 *                         "sections": [
 *                             {
 *                                 "startPointIndex": 0,
 *                                 "endPointIndex": 40,
 *                                 "sectionType": "TRAVEL_MODE",
 *                                 "travelMode": "bicycle"
 *                             }
 *                         ]
 *                     }
 *                 ]
 *             }
 *         },
 *         {
 *             "statusCode": 400,
 *             "response":
 *             {
 *                 "error":
 *                 {
 *                     "code": "400 BadRequest",
 *                     "message": "Bad request: one or more parameters were incorrectly specified or are mutually exclusive."
 *                 }
 *             }
 *         }
 *     ]
 * }
 * ```
 */
export declare interface RouteRequestRouteDirectionsBatchSync200Response extends HttpResponse {
    status: "200";
    body: RouteDirectionsBatchResultOutput;
}

/**
 * **Route Directions Batch API**
 *
 *
 * **Applies to**: see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
 *
 *
 *
 * The Route Directions Batch API sends batches of queries to [Route Directions API](https://docs.microsoft.com/rest/api/maps/route/getroutedirections) using just a single API call. You can call Route Directions Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to **700** queries and sync API up to **100** queries.
 * ### Submit Synchronous Batch Request
 * The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond as soon as the batch items are calculated and there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer than 60 seconds. The number of batch items is limited to **100** for this API.
 * ```
 * POST https://atlas.microsoft.com/route/directions/batch/sync/json?api-version=1.0&subscription-key={subscription-key}
 * ```
 * ### Batch Response Model
 * The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the batch has finished processing, the response body contains the batch response. This batch response contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems` array which contains a response for each and every query in the batch request. The `batchItems` will contain the results in the exact same order the original queries were sent in the batch request. Each item in `batchItems` contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
 *
 *   - [`RouteDirections`](https://docs.microsoft.com/rest/api/maps/route/getroutedirections#routedirections) - If the query completed successfully.
 *
 *   - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
 *
 *
 * Here's a sample Batch Response with 1 _successful_ and 1 _failed_ result:
 *
 *
 * ```json
 * {
 *     "summary": {
 *         "successfulRequests": 1,
 *         "totalRequests": 2
 *     },
 *     "batchItems": [
 *         {
 *             "statusCode": 200,
 *             "response": {
 *                 "routes": [
 *                     {
 *                         "summary": {
 *                             "lengthInMeters": 1758,
 *                             "travelTimeInSeconds": 387,
 *                             "trafficDelayInSeconds": 0,
 *                             "departureTime": "2018-07-17T00:49:56+00:00",
 *                             "arrivalTime": "2018-07-17T00:56:22+00:00"
 *                         },
 *                         "legs": [
 *                             {
 *                                 "summary": {
 *                                     "lengthInMeters": 1758,
 *                                     "travelTimeInSeconds": 387,
 *                                     "trafficDelayInSeconds": 0,
 *                                     "departureTime": "2018-07-17T00:49:56+00:00",
 *                                     "arrivalTime": "2018-07-17T00:56:22+00:00"
 *                                 },
 *                                 "points": [
 *                                     {
 *                                         "latitude": 47.62094,
 *                                         "longitude": -122.34892
 *                                     },
 *                                     {
 *                                         "latitude": 47.62094,
 *                                         "longitude": -122.3485
 *                                     },
 *                                     {
 *                                         "latitude": 47.62095,
 *                                         "longitude": -122.3476
 *                                     }
 *                                 ]
 *                             }
 *                         ],
 *                         "sections": [
 *                             {
 *                                 "startPointIndex": 0,
 *                                 "endPointIndex": 40,
 *                                 "sectionType": "TRAVEL_MODE",
 *                                 "travelMode": "bicycle"
 *                             }
 *                         ]
 *                     }
 *                 ]
 *             }
 *         },
 *         {
 *             "statusCode": 400,
 *             "response":
 *             {
 *                 "error":
 *                 {
 *                     "code": "400 BadRequest",
 *                     "message": "Bad request: one or more parameters were incorrectly specified or are mutually exclusive."
 *                 }
 *             }
 *         }
 *     ]
 * }
 * ```
 */
export declare interface RouteRequestRouteDirectionsBatchSync408Response extends HttpResponse {
    status: "408";
    body: ErrorResponseOutput;
}

export declare interface RouteRequestRouteDirectionsBatchSyncBodyParam {
    /** The list of route directions queries/requests to process. The list can contain  a max of 700 queries for async and 100 queries for sync version and must contain at least 1 query. */
    body: BatchRequest;
}

/**
 * **Route Directions Batch API**
 *
 *
 * **Applies to**: see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
 *
 *
 *
 * The Route Directions Batch API sends batches of queries to [Route Directions API](https://docs.microsoft.com/rest/api/maps/route/getroutedirections) using just a single API call. You can call Route Directions Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to **700** queries and sync API up to **100** queries.
 * ### Submit Synchronous Batch Request
 * The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond as soon as the batch items are calculated and there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer than 60 seconds. The number of batch items is limited to **100** for this API.
 * ```
 * POST https://atlas.microsoft.com/route/directions/batch/sync/json?api-version=1.0&subscription-key={subscription-key}
 * ```
 * ### Batch Response Model
 * The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the batch has finished processing, the response body contains the batch response. This batch response contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems` array which contains a response for each and every query in the batch request. The `batchItems` will contain the results in the exact same order the original queries were sent in the batch request. Each item in `batchItems` contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
 *
 *   - [`RouteDirections`](https://docs.microsoft.com/rest/api/maps/route/getroutedirections#routedirections) - If the query completed successfully.
 *
 *   - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
 *
 *
 * Here's a sample Batch Response with 1 _successful_ and 1 _failed_ result:
 *
 *
 * ```json
 * {
 *     "summary": {
 *         "successfulRequests": 1,
 *         "totalRequests": 2
 *     },
 *     "batchItems": [
 *         {
 *             "statusCode": 200,
 *             "response": {
 *                 "routes": [
 *                     {
 *                         "summary": {
 *                             "lengthInMeters": 1758,
 *                             "travelTimeInSeconds": 387,
 *                             "trafficDelayInSeconds": 0,
 *                             "departureTime": "2018-07-17T00:49:56+00:00",
 *                             "arrivalTime": "2018-07-17T00:56:22+00:00"
 *                         },
 *                         "legs": [
 *                             {
 *                                 "summary": {
 *                                     "lengthInMeters": 1758,
 *                                     "travelTimeInSeconds": 387,
 *                                     "trafficDelayInSeconds": 0,
 *                                     "departureTime": "2018-07-17T00:49:56+00:00",
 *                                     "arrivalTime": "2018-07-17T00:56:22+00:00"
 *                                 },
 *                                 "points": [
 *                                     {
 *                                         "latitude": 47.62094,
 *                                         "longitude": -122.34892
 *                                     },
 *                                     {
 *                                         "latitude": 47.62094,
 *                                         "longitude": -122.3485
 *                                     },
 *                                     {
 *                                         "latitude": 47.62095,
 *                                         "longitude": -122.3476
 *                                     }
 *                                 ]
 *                             }
 *                         ],
 *                         "sections": [
 *                             {
 *                                 "startPointIndex": 0,
 *                                 "endPointIndex": 40,
 *                                 "sectionType": "TRAVEL_MODE",
 *                                 "travelMode": "bicycle"
 *                             }
 *                         ]
 *                     }
 *                 ]
 *             }
 *         },
 *         {
 *             "statusCode": 400,
 *             "response":
 *             {
 *                 "error":
 *                 {
 *                     "code": "400 BadRequest",
 *                     "message": "Bad request: one or more parameters were incorrectly specified or are mutually exclusive."
 *                 }
 *             }
 *         }
 *     ]
 * }
 * ```
 */
export declare interface RouteRequestRouteDirectionsBatchSyncDefaultResponse extends HttpResponse {
    status: string;
    body: ErrorResponseOutput;
}

export declare interface RouteRequestRouteDirectionsBatchSyncMediaTypesParam {
    /** Request content type */
    contentType?: "application/json";
}

export declare type RouteRequestRouteDirectionsBatchSyncParameters = RouteRequestRouteDirectionsBatchSyncMediaTypesParam & RouteRequestRouteDirectionsBatchSyncBodyParam & RequestParameters;

/**
 *
 * **Applies to**: see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
 *
 * The Matrix Routing service allows calculation of a matrix of route summaries for a set of routes defined by origin and destination locations by using an asynchronous (async) or synchronous (sync) POST request. For every given origin, the service calculates the cost of routing from that origin to every given destination. The set of origins and the set of destinations can be thought of as the column and row headers of a table and each cell in the table contains the costs of routing from the origin to the destination for that cell. As an example, let's say a food delivery company has 20 drivers and they need to find the closest driver to pick up the delivery from the restaurant. To solve this use case, they can call Matrix Route API.
 *
 *
 * For each route, the travel times and distances are returned. You can use the computed costs to determine which detailed routes to calculate using the Route Directions API.
 *
 *
 * The maximum size of a matrix for async request is **700** and for sync request it's **100** (the number of origins multiplied by the number of destinations).
 *
 *
 *
 * ### Submit Synchronous Route Matrix Request
 * If your scenario requires synchronous requests and the maximum size of the matrix is less than or equal to 100, you might want to make synchronous request. The maximum size of a matrix for this API is **100** (the number of origins multiplied by the number of destinations). With that constraint in mind, examples of possible matrix dimensions are: 10x10, 6x8, 9x8 (it does not need to be square).
 *
 * ```
 * POST https://atlas.microsoft.com/route/matrix/sync/json?api-version=1.0&subscription-key={subscription-key}
 * ```
 *
 * ### Submit Asynchronous Route Matrix Request
 * The Asynchronous API is appropriate for processing big volumes of relatively complex routing requests. When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the response header. This URL should be checked periodically until the response data or error information is available. If `waitForResults` parameter in the request is set to true, user will get a 200 response if the request is finished under 120 seconds.
 *
 *
 * The maximum size of a matrix for this API is **700** (the number of origins multiplied by the number of destinations). With that constraint in mind, examples of possible matrix dimensions are: 50x10, 10x10, 28x25. 10x70 (it does not need to be square).
 *
 *
 * The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the expiration period.
 *
 *
 *
 *
 * ```
 * POST https://atlas.microsoft.com/route/matrix/json?api-version=1.0&subscription-key={subscription-key}
 * ```
 *
 * Here's a typical sequence of asynchronous operations:
 * 1. Client sends a Route Matrix POST request to Azure Maps
 *
 * 2. The server will respond with one of the following:
 *
 *     > HTTP `202 Accepted` -  Route Matrix request has been accepted.
 *
 *     > HTTP `Error` - There was an error processing your Route Matrix request. This could either be a 400 Bad Request or any other Error status code.
 *
 *
 * 3. If the Matrix Route request was accepted successfully, the Location header in the response contains the URL to download the results of the request. This status URI looks like the following:
 *
 *   ```
 *     GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
 *   ```
 *
 *
 * 4. Client issues a GET request on the download URL obtained in Step 3 to download the results
 *
 * ### Download Sync Results
 * When you make a POST request for Route Matrix Sync API, the service returns 200 response code for successful request and a response array. The response body will contain the data and there will be no possibility to retrieve the results later.
 *
 * ### Download Async Results
 * When a request issues a `202 Accepted` response, the request is being processed using our async pipeline. You will be given a URL to check the progress of your  async request in the location header of the response. This status URI looks like the following:
 * ```
 *   GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
 * ```
 *
 * The URL provided by the location header will return the following responses when a `GET` request is issued.
 *
 *   > HTTP `202 Accepted` - Matrix request was accepted but is still being processed. Please try again in some time.
 *
 *   > HTTP `200 OK` - Matrix request successfully processed. The response body contains all of the results.
 */
export declare interface RouteRequestRouteMatrix200Response extends HttpResponse {
    status: "200";
    body: RouteMatrixResultOutput;
}

export declare interface RouteRequestRouteMatrix202Headers {
    /** New URL to check for the results of the long running process. */
    location?: string;
}

/**
 *
 * **Applies to**: see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
 *
 * The Matrix Routing service allows calculation of a matrix of route summaries for a set of routes defined by origin and destination locations by using an asynchronous (async) or synchronous (sync) POST request. For every given origin, the service calculates the cost of routing from that origin to every given destination. The set of origins and the set of destinations can be thought of as the column and row headers of a table and each cell in the table contains the costs of routing from the origin to the destination for that cell. As an example, let's say a food delivery company has 20 drivers and they need to find the closest driver to pick up the delivery from the restaurant. To solve this use case, they can call Matrix Route API.
 *
 *
 * For each route, the travel times and distances are returned. You can use the computed costs to determine which detailed routes to calculate using the Route Directions API.
 *
 *
 * The maximum size of a matrix for async request is **700** and for sync request it's **100** (the number of origins multiplied by the number of destinations).
 *
 *
 *
 * ### Submit Synchronous Route Matrix Request
 * If your scenario requires synchronous requests and the maximum size of the matrix is less than or equal to 100, you might want to make synchronous request. The maximum size of a matrix for this API is **100** (the number of origins multiplied by the number of destinations). With that constraint in mind, examples of possible matrix dimensions are: 10x10, 6x8, 9x8 (it does not need to be square).
 *
 * ```
 * POST https://atlas.microsoft.com/route/matrix/sync/json?api-version=1.0&subscription-key={subscription-key}
 * ```
 *
 * ### Submit Asynchronous Route Matrix Request
 * The Asynchronous API is appropriate for processing big volumes of relatively complex routing requests. When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the response header. This URL should be checked periodically until the response data or error information is available. If `waitForResults` parameter in the request is set to true, user will get a 200 response if the request is finished under 120 seconds.
 *
 *
 * The maximum size of a matrix for this API is **700** (the number of origins multiplied by the number of destinations). With that constraint in mind, examples of possible matrix dimensions are: 50x10, 10x10, 28x25. 10x70 (it does not need to be square).
 *
 *
 * The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the expiration period.
 *
 *
 *
 *
 * ```
 * POST https://atlas.microsoft.com/route/matrix/json?api-version=1.0&subscription-key={subscription-key}
 * ```
 *
 * Here's a typical sequence of asynchronous operations:
 * 1. Client sends a Route Matrix POST request to Azure Maps
 *
 * 2. The server will respond with one of the following:
 *
 *     > HTTP `202 Accepted` -  Route Matrix request has been accepted.
 *
 *     > HTTP `Error` - There was an error processing your Route Matrix request. This could either be a 400 Bad Request or any other Error status code.
 *
 *
 * 3. If the Matrix Route request was accepted successfully, the Location header in the response contains the URL to download the results of the request. This status URI looks like the following:
 *
 *   ```
 *     GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
 *   ```
 *
 *
 * 4. Client issues a GET request on the download URL obtained in Step 3 to download the results
 *
 * ### Download Sync Results
 * When you make a POST request for Route Matrix Sync API, the service returns 200 response code for successful request and a response array. The response body will contain the data and there will be no possibility to retrieve the results later.
 *
 * ### Download Async Results
 * When a request issues a `202 Accepted` response, the request is being processed using our async pipeline. You will be given a URL to check the progress of your  async request in the location header of the response. This status URI looks like the following:
 * ```
 *   GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
 * ```
 *
 * The URL provided by the location header will return the following responses when a `GET` request is issued.
 *
 *   > HTTP `202 Accepted` - Matrix request was accepted but is still being processed. Please try again in some time.
 *
 *   > HTTP `200 OK` - Matrix request successfully processed. The response body contains all of the results.
 */
export declare interface RouteRequestRouteMatrix202Response extends HttpResponse {
    status: "202";
    body: Record<string, unknown>;
    headers: RawHttpHeaders & RouteRequestRouteMatrix202Headers;
}

export declare interface RouteRequestRouteMatrixBodyParam {
    /** The matrix of origin and destination coordinates to compute the route distance, travel time and other summary for each cell of the matrix based on the input parameters. The minimum and the maximum cell count supported are 1 and **700** for async and **100** for sync respectively. For example, it can be 35 origins and 20 destinations or 25 origins and 25 destinations for async API. */
    body: RouteMatrixQuery;
}

export declare interface RouteRequestRouteMatrixMediaTypesParam {
    /** Request content type */
    contentType?: "application/json";
}

export declare type RouteRequestRouteMatrixParameters = RouteRequestRouteMatrixQueryParam & RouteRequestRouteMatrixMediaTypesParam & RouteRequestRouteMatrixBodyParam & RequestParameters;

export declare interface RouteRequestRouteMatrixQueryParam {
    queryParameters?: RouteRequestRouteMatrixQueryParamProperties;
}

export declare interface RouteRequestRouteMatrixQueryParamProperties {
    /** Boolean to indicate whether to execute the request synchronously. If set to true, user will get a 200 response if the request is finished under 120 seconds. Otherwise, user will get a 202 response right away. Please refer to the API description for more details on 202 response. **Supported only for async request**. */
    waitForResults?: boolean;
    /** Specifies whether to return additional travel times using different types of traffic information (none, historic, live) as well as the default best-estimate travel time. */
    computeTravelTimeFor?: "none" | "all";
    /** Specifies which of the section types is reported in the route response. <br><br>For example if sectionType = pedestrian the sections which are suited for pedestrians only are returned. Multiple types can be used. The default sectionType refers to the travelMode input. By default travelMode is set to car */
    sectionType?: "carTrain" | "country" | "ferry" | "motorway" | "pedestrian" | "tollRoad" | "tollVignette" | "traffic" | "travelMode" | "tunnel" | "carpool" | "urban";
    /** The date and time of arrival at the destination point. It must be specified as a dateTime. When a time zone offset is not specified it will be assumed to be that of the destination point. The arriveAt value must be in the future. The arriveAt parameter cannot be used in conjunction with departAt, minDeviationDistance or minDeviationTime. */
    arriveAt?: Date | string;
    /** The date and time of departure from the origin point. Departure times apart from now must be specified as a dateTime. When a time zone offset is not specified, it will be assumed to be that of the origin point. The departAt value must be in the future in the date-time format (1996-12-19T16:39:57-08:00). */
    departAt?: Date | string;
    /** Weight per axle of the vehicle in kg. A value of 0 means that weight restrictions per axle are not considered. */
    vehicleAxleWeight?: number;
    /** Length of the vehicle in meters. A value of 0 means that length restrictions are not considered. */
    vehicleLength?: number;
    /** Height of the vehicle in meters. A value of 0 means that height restrictions are not considered. */
    vehicleHeight?: number;
    /** Width of the vehicle in meters. A value of 0 means that width restrictions are not considered. */
    vehicleWidth?: number;
    /**
     * Maximum speed of the vehicle in km/hour. The max speed in the vehicle profile is used to check whether a vehicle is allowed on motorways.
     *
     * * A value of 0 means that an appropriate value for the vehicle will be determined and applied during route planning.
     *
     * * A non-zero value may be overridden during route planning. For example, the current traffic flow is 60 km/hour. If the vehicle  maximum speed is set to 50 km/hour, the routing engine will consider 60 km/hour as this is the current situation.  If the maximum speed of the vehicle is provided as 80 km/hour but the current traffic flow is 60 km/hour, then routing engine will again use 60 km/hour.
     */
    vehicleMaxSpeed?: number;
    /** Weight of the vehicle in kilograms. */
    vehicleWeight?: number;
    /** Level of turns for thrilling route. This parameter can only be used in conjunction with `routeType`=thrilling. */
    windingness?: "low" | "normal" | "high";
    /** Degree of hilliness for thrilling route. This parameter can only be used in conjunction with `routeType`=thrilling. */
    hilliness?: "low" | "normal" | "high";
    /** The mode of travel for the requested route. If not defined, default is 'car'. Note that the requested travelMode may not be available for the entire route. Where the requested travelMode is not available for a particular section, the travelMode element of the response for that section will be "other". Note that travel modes bus, motorcycle, taxi and van are BETA functionality. Full restriction data is not available in all areas. In **calculateReachableRange** requests, the values bicycle and pedestrian must not be used. */
    travelMode?: "car" | "truck" | "taxi" | "bus" | "van" | "motorcycle" | "bicycle" | "pedestrian";
    /** Specifies something that the route calculation should try to avoid when determining the route. Can be specified multiple times in one request, for example, '&avoid=motorways&avoid=tollRoads&avoid=ferries'. In calculateReachableRange requests, the value alreadyUsedRoads must not be used. */
    avoid?: Array<"tollRoads" | "motorways" | "ferries" | "unpavedRoads" | "carpools" | "alreadyUsedRoads" | "borderCrossings">;
    /**
     * Possible values:
     *   * true - Do consider all available traffic information during routing
     *   * false - Ignore current traffic data during routing. Note that although the current traffic data is ignored
     *   during routing, the effect of historic traffic on effective road speeds is still incorporated.
     */
    traffic?: boolean;
    /** The type of route requested. */
    routeType?: "fastest" | "shortest" | "eco" | "thrilling";
    /** Types of cargo that may be classified as hazardous materials and restricted from some roads. Available vehicleLoadType values are US Hazmat classes 1 through 9, plus generic classifications for use in other countries. Values beginning with USHazmat are for US routing while otherHazmat should be used for all other countries. vehicleLoadType can be specified multiple times. This parameter is currently only considered for travelMode=truck. */
    vehicleLoadType?: "USHazmatClass1" | "USHazmatClass2" | "USHazmatClass3" | "USHazmatClass4" | "USHazmatClass5" | "USHazmatClass6" | "USHazmatClass7" | "USHazmatClass8" | "USHazmatClass9" | "otherHazmatExplosive" | "otherHazmatGeneral" | "otherHazmatHarmfulToWater";
}

/**
 *
 * **Applies to**: see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
 *
 * The Matrix Routing service allows calculation of a matrix of route summaries for a set of routes defined by origin and destination locations by using an asynchronous (async) or synchronous (sync) POST request. For every given origin, the service calculates the cost of routing from that origin to every given destination. The set of origins and the set of destinations can be thought of as the column and row headers of a table and each cell in the table contains the costs of routing from the origin to the destination for that cell. As an example, let's say a food delivery company has 20 drivers and they need to find the closest driver to pick up the delivery from the restaurant. To solve this use case, they can call Matrix Route API.
 *
 *
 * For each route, the travel times and distances are returned. You can use the computed costs to determine which detailed routes to calculate using the Route Directions API.
 *
 *
 * The maximum size of a matrix for async request is **700** and for sync request it's **100** (the number of origins multiplied by the number of destinations).
 *
 *
 *
 * ### Submit Synchronous Route Matrix Request
 * If your scenario requires synchronous requests and the maximum size of the matrix is less than or equal to 100, you might want to make synchronous request. The maximum size of a matrix for this API is **100** (the number of origins multiplied by the number of destinations). With that constraint in mind, examples of possible matrix dimensions are: 10x10, 6x8, 9x8 (it does not need to be square).
 *
 * ```
 * POST https://atlas.microsoft.com/route/matrix/sync/json?api-version=1.0&subscription-key={subscription-key}
 * ```
 *
 * ### Submit Asynchronous Route Matrix Request
 * The Asynchronous API is appropriate for processing big volumes of relatively complex routing requests. When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the response header. This URL should be checked periodically until the response data or error information is available. If `waitForResults` parameter in the request is set to true, user will get a 200 response if the request is finished under 120 seconds.
 *
 *
 * The maximum size of a matrix for this API is **700** (the number of origins multiplied by the number of destinations). With that constraint in mind, examples of possible matrix dimensions are: 50x10, 10x10, 28x25. 10x70 (it does not need to be square).
 *
 *
 * The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the expiration period.
 *
 *
 *
 *
 * ```
 * POST https://atlas.microsoft.com/route/matrix/json?api-version=1.0&subscription-key={subscription-key}
 * ```
 *
 * Here's a typical sequence of asynchronous operations:
 * 1. Client sends a Route Matrix POST request to Azure Maps
 *
 * 2. The server will respond with one of the following:
 *
 *     > HTTP `202 Accepted` -  Route Matrix request has been accepted.
 *
 *     > HTTP `Error` - There was an error processing your Route Matrix request. This could either be a 400 Bad Request or any other Error status code.
 *
 *
 * 3. If the Matrix Route request was accepted successfully, the Location header in the response contains the URL to download the results of the request. This status URI looks like the following:
 *
 *   ```
 *     GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
 *   ```
 *
 *
 * 4. Client issues a GET request on the download URL obtained in Step 3 to download the results
 *
 * ### Download Sync Results
 * When you make a POST request for Route Matrix Sync API, the service returns 200 response code for successful request and a response array. The response body will contain the data and there will be no possibility to retrieve the results later.
 *
 * ### Download Async Results
 * When a request issues a `202 Accepted` response, the request is being processed using our async pipeline. You will be given a URL to check the progress of your  async request in the location header of the response. This status URI looks like the following:
 * ```
 *   GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
 * ```
 *
 * The URL provided by the location header will return the following responses when a `GET` request is issued.
 *
 *   > HTTP `202 Accepted` - Matrix request was accepted but is still being processed. Please try again in some time.
 *
 *   > HTTP `200 OK` - Matrix request successfully processed. The response body contains all of the results.
 */
export declare interface RouteRequestRouteMatrixSync200Response extends HttpResponse {
    status: "200";
    body: RouteMatrixResultOutput;
}

/**
 *
 * **Applies to**: see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
 *
 * The Matrix Routing service allows calculation of a matrix of route summaries for a set of routes defined by origin and destination locations by using an asynchronous (async) or synchronous (sync) POST request. For every given origin, the service calculates the cost of routing from that origin to every given destination. The set of origins and the set of destinations can be thought of as the column and row headers of a table and each cell in the table contains the costs of routing from the origin to the destination for that cell. As an example, let's say a food delivery company has 20 drivers and they need to find the closest driver to pick up the delivery from the restaurant. To solve this use case, they can call Matrix Route API.
 *
 *
 * For each route, the travel times and distances are returned. You can use the computed costs to determine which detailed routes to calculate using the Route Directions API.
 *
 *
 * The maximum size of a matrix for async request is **700** and for sync request it's **100** (the number of origins multiplied by the number of destinations).
 *
 *
 *
 * ### Submit Synchronous Route Matrix Request
 * If your scenario requires synchronous requests and the maximum size of the matrix is less than or equal to 100, you might want to make synchronous request. The maximum size of a matrix for this API is **100** (the number of origins multiplied by the number of destinations). With that constraint in mind, examples of possible matrix dimensions are: 10x10, 6x8, 9x8 (it does not need to be square).
 *
 * ```
 * POST https://atlas.microsoft.com/route/matrix/sync/json?api-version=1.0&subscription-key={subscription-key}
 * ```
 *
 * ### Submit Asynchronous Route Matrix Request
 * The Asynchronous API is appropriate for processing big volumes of relatively complex routing requests. When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the response header. This URL should be checked periodically until the response data or error information is available. If `waitForResults` parameter in the request is set to true, user will get a 200 response if the request is finished under 120 seconds.
 *
 *
 * The maximum size of a matrix for this API is **700** (the number of origins multiplied by the number of destinations). With that constraint in mind, examples of possible matrix dimensions are: 50x10, 10x10, 28x25. 10x70 (it does not need to be square).
 *
 *
 * The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the expiration period.
 *
 *
 *
 *
 * ```
 * POST https://atlas.microsoft.com/route/matrix/json?api-version=1.0&subscription-key={subscription-key}
 * ```
 *
 * Here's a typical sequence of asynchronous operations:
 * 1. Client sends a Route Matrix POST request to Azure Maps
 *
 * 2. The server will respond with one of the following:
 *
 *     > HTTP `202 Accepted` -  Route Matrix request has been accepted.
 *
 *     > HTTP `Error` - There was an error processing your Route Matrix request. This could either be a 400 Bad Request or any other Error status code.
 *
 *
 * 3. If the Matrix Route request was accepted successfully, the Location header in the response contains the URL to download the results of the request. This status URI looks like the following:
 *
 *   ```
 *     GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
 *   ```
 *
 *
 * 4. Client issues a GET request on the download URL obtained in Step 3 to download the results
 *
 * ### Download Sync Results
 * When you make a POST request for Route Matrix Sync API, the service returns 200 response code for successful request and a response array. The response body will contain the data and there will be no possibility to retrieve the results later.
 *
 * ### Download Async Results
 * When a request issues a `202 Accepted` response, the request is being processed using our async pipeline. You will be given a URL to check the progress of your  async request in the location header of the response. This status URI looks like the following:
 * ```
 *   GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
 * ```
 *
 * The URL provided by the location header will return the following responses when a `GET` request is issued.
 *
 *   > HTTP `202 Accepted` - Matrix request was accepted but is still being processed. Please try again in some time.
 *
 *   > HTTP `200 OK` - Matrix request successfully processed. The response body contains all of the results.
 */
export declare interface RouteRequestRouteMatrixSync408Response extends HttpResponse {
    status: "408";
    body: ErrorResponseOutput;
}

export declare interface RouteRequestRouteMatrixSyncBodyParam {
    /** The matrix of origin and destination coordinates to compute the route distance, travel time and other summary for each cell of the matrix based on the input parameters. The minimum and the maximum cell count supported are 1 and **700** for async and **100** for sync respectively. For example, it can be 35 origins and 20 destinations or 25 origins and 25 destinations for async API. */
    body: RouteMatrixQuery;
}

/**
 *
 * **Applies to**: see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
 *
 * The Matrix Routing service allows calculation of a matrix of route summaries for a set of routes defined by origin and destination locations by using an asynchronous (async) or synchronous (sync) POST request. For every given origin, the service calculates the cost of routing from that origin to every given destination. The set of origins and the set of destinations can be thought of as the column and row headers of a table and each cell in the table contains the costs of routing from the origin to the destination for that cell. As an example, let's say a food delivery company has 20 drivers and they need to find the closest driver to pick up the delivery from the restaurant. To solve this use case, they can call Matrix Route API.
 *
 *
 * For each route, the travel times and distances are returned. You can use the computed costs to determine which detailed routes to calculate using the Route Directions API.
 *
 *
 * The maximum size of a matrix for async request is **700** and for sync request it's **100** (the number of origins multiplied by the number of destinations).
 *
 *
 *
 * ### Submit Synchronous Route Matrix Request
 * If your scenario requires synchronous requests and the maximum size of the matrix is less than or equal to 100, you might want to make synchronous request. The maximum size of a matrix for this API is **100** (the number of origins multiplied by the number of destinations). With that constraint in mind, examples of possible matrix dimensions are: 10x10, 6x8, 9x8 (it does not need to be square).
 *
 * ```
 * POST https://atlas.microsoft.com/route/matrix/sync/json?api-version=1.0&subscription-key={subscription-key}
 * ```
 *
 * ### Submit Asynchronous Route Matrix Request
 * The Asynchronous API is appropriate for processing big volumes of relatively complex routing requests. When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the response header. This URL should be checked periodically until the response data or error information is available. If `waitForResults` parameter in the request is set to true, user will get a 200 response if the request is finished under 120 seconds.
 *
 *
 * The maximum size of a matrix for this API is **700** (the number of origins multiplied by the number of destinations). With that constraint in mind, examples of possible matrix dimensions are: 50x10, 10x10, 28x25. 10x70 (it does not need to be square).
 *
 *
 * The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the expiration period.
 *
 *
 *
 *
 * ```
 * POST https://atlas.microsoft.com/route/matrix/json?api-version=1.0&subscription-key={subscription-key}
 * ```
 *
 * Here's a typical sequence of asynchronous operations:
 * 1. Client sends a Route Matrix POST request to Azure Maps
 *
 * 2. The server will respond with one of the following:
 *
 *     > HTTP `202 Accepted` -  Route Matrix request has been accepted.
 *
 *     > HTTP `Error` - There was an error processing your Route Matrix request. This could either be a 400 Bad Request or any other Error status code.
 *
 *
 * 3. If the Matrix Route request was accepted successfully, the Location header in the response contains the URL to download the results of the request. This status URI looks like the following:
 *
 *   ```
 *     GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
 *   ```
 *
 *
 * 4. Client issues a GET request on the download URL obtained in Step 3 to download the results
 *
 * ### Download Sync Results
 * When you make a POST request for Route Matrix Sync API, the service returns 200 response code for successful request and a response array. The response body will contain the data and there will be no possibility to retrieve the results later.
 *
 * ### Download Async Results
 * When a request issues a `202 Accepted` response, the request is being processed using our async pipeline. You will be given a URL to check the progress of your  async request in the location header of the response. This status URI looks like the following:
 * ```
 *   GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
 * ```
 *
 * The URL provided by the location header will return the following responses when a `GET` request is issued.
 *
 *   > HTTP `202 Accepted` - Matrix request was accepted but is still being processed. Please try again in some time.
 *
 *   > HTTP `200 OK` - Matrix request successfully processed. The response body contains all of the results.
 */
export declare interface RouteRequestRouteMatrixSyncDefaultResponse extends HttpResponse {
    status: string;
    body: ErrorResponseOutput;
}

export declare interface RouteRequestRouteMatrixSyncMediaTypesParam {
    /** Request content type */
    contentType?: "application/json";
}

export declare type RouteRequestRouteMatrixSyncParameters = RouteRequestRouteMatrixSyncQueryParam & RouteRequestRouteMatrixSyncMediaTypesParam & RouteRequestRouteMatrixSyncBodyParam & RequestParameters;

export declare interface RouteRequestRouteMatrixSyncQueryParam {
    queryParameters?: RouteRequestRouteMatrixSyncQueryParamProperties;
}

export declare interface RouteRequestRouteMatrixSyncQueryParamProperties {
    /** Boolean to indicate whether to execute the request synchronously. If set to true, user will get a 200 response if the request is finished under 120 seconds. Otherwise, user will get a 202 response right away. Please refer to the API description for more details on 202 response. **Supported only for async request**. */
    waitForResults?: boolean;
    /** Specifies whether to return additional travel times using different types of traffic information (none, historic, live) as well as the default best-estimate travel time. */
    computeTravelTimeFor?: "none" | "all";
    /** Specifies which of the section types is reported in the route response. <br><br>For example if sectionType = pedestrian the sections which are suited for pedestrians only are returned. Multiple types can be used. The default sectionType refers to the travelMode input. By default travelMode is set to car */
    sectionType?: "carTrain" | "country" | "ferry" | "motorway" | "pedestrian" | "tollRoad" | "tollVignette" | "traffic" | "travelMode" | "tunnel" | "carpool" | "urban";
    /** The date and time of arrival at the destination point. It must be specified as a dateTime. When a time zone offset is not specified it will be assumed to be that of the destination point. The arriveAt value must be in the future. The arriveAt parameter cannot be used in conjunction with departAt, minDeviationDistance or minDeviationTime. */
    arriveAt?: Date | string;
    /** The date and time of departure from the origin point. Departure times apart from now must be specified as a dateTime. When a time zone offset is not specified, it will be assumed to be that of the origin point. The departAt value must be in the future in the date-time format (1996-12-19T16:39:57-08:00). */
    departAt?: Date | string;
    /** Weight per axle of the vehicle in kg. A value of 0 means that weight restrictions per axle are not considered. */
    vehicleAxleWeight?: number;
    /** Length of the vehicle in meters. A value of 0 means that length restrictions are not considered. */
    vehicleLength?: number;
    /** Height of the vehicle in meters. A value of 0 means that height restrictions are not considered. */
    vehicleHeight?: number;
    /** Width of the vehicle in meters. A value of 0 means that width restrictions are not considered. */
    vehicleWidth?: number;
    /**
     * Maximum speed of the vehicle in km/hour. The max speed in the vehicle profile is used to check whether a vehicle is allowed on motorways.
     *
     * * A value of 0 means that an appropriate value for the vehicle will be determined and applied during route planning.
     *
     * * A non-zero value may be overridden during route planning. For example, the current traffic flow is 60 km/hour. If the vehicle  maximum speed is set to 50 km/hour, the routing engine will consider 60 km/hour as this is the current situation.  If the maximum speed of the vehicle is provided as 80 km/hour but the current traffic flow is 60 km/hour, then routing engine will again use 60 km/hour.
     */
    vehicleMaxSpeed?: number;
    /** Weight of the vehicle in kilograms. */
    vehicleWeight?: number;
    /** Level of turns for thrilling route. This parameter can only be used in conjunction with `routeType`=thrilling. */
    windingness?: "low" | "normal" | "high";
    /** Degree of hilliness for thrilling route. This parameter can only be used in conjunction with `routeType`=thrilling. */
    hilliness?: "low" | "normal" | "high";
    /** The mode of travel for the requested route. If not defined, default is 'car'. Note that the requested travelMode may not be available for the entire route. Where the requested travelMode is not available for a particular section, the travelMode element of the response for that section will be "other". Note that travel modes bus, motorcycle, taxi and van are BETA functionality. Full restriction data is not available in all areas. In **calculateReachableRange** requests, the values bicycle and pedestrian must not be used. */
    travelMode?: "car" | "truck" | "taxi" | "bus" | "van" | "motorcycle" | "bicycle" | "pedestrian";
    /** Specifies something that the route calculation should try to avoid when determining the route. Can be specified multiple times in one request, for example, '&avoid=motorways&avoid=tollRoads&avoid=ferries'. In calculateReachableRange requests, the value alreadyUsedRoads must not be used. */
    avoid?: Array<"tollRoads" | "motorways" | "ferries" | "unpavedRoads" | "carpools" | "alreadyUsedRoads" | "borderCrossings">;
    /**
     * Possible values:
     *   * true - Do consider all available traffic information during routing
     *   * false - Ignore current traffic data during routing. Note that although the current traffic data is ignored
     *   during routing, the effect of historic traffic on effective road speeds is still incorporated.
     */
    traffic?: boolean;
    /** The type of route requested. */
    routeType?: "fastest" | "shortest" | "eco" | "thrilling";
    /** Types of cargo that may be classified as hazardous materials and restricted from some roads. Available vehicleLoadType values are US Hazmat classes 1 through 9, plus generic classifications for use in other countries. Values beginning with USHazmat are for US routing while otherHazmat should be used for all other countries. vehicleLoadType can be specified multiple times. This parameter is currently only considered for travelMode=truck. */
    vehicleLoadType?: "USHazmatClass1" | "USHazmatClass2" | "USHazmatClass3" | "USHazmatClass4" | "USHazmatClass5" | "USHazmatClass6" | "USHazmatClass7" | "USHazmatClass8" | "USHazmatClass9" | "otherHazmatExplosive" | "otherHazmatGeneral" | "otherHazmatHarmfulToWater";
}

export declare interface Routes {
    /** Resource for '/route/matrix/\{format\}' has methods for the following verbs: post, get */
    (path: "/route/matrix/{format}", format: "json"): RequestRouteMatrix;
    /** Resource for '/route/matrix/sync/\{format\}' has methods for the following verbs: post */
    (path: "/route/matrix/sync/{format}", format: "json"): RequestRouteMatrixSync;
    /** Resource for '/route/directions/\{format\}' has methods for the following verbs: get, post */
    (path: "/route/directions/{format}", format: "json" | "xml"): GetRouteDirections;
    /** Resource for '/route/range/\{format\}' has methods for the following verbs: get */
    (path: "/route/range/{format}", format: "json" | "xml"): GetRouteRange;
    /** Resource for '/route/directions/batch/\{format\}' has methods for the following verbs: post, get */
    (path: "/route/directions/batch/{format}", format: "json"): RequestRouteDirectionsBatch;
    /** Resource for '/route/directions/batch/sync/\{format\}' has methods for the following verbs: post */
    (path: "/route/directions/batch/sync/{format}", format: "json"): RequestRouteDirectionsBatchSync;
}

/** Route sections contain additional information about parts of a route. Each section contains at least the elements `startPointIndex`, `endPointIndex`, and `sectionType`. */
export declare interface RouteSectionOutput {
    /** Index of the first point (offset 0) in the route this section applies to. */
    startPointIndex: number;
    /** Index of the last point (offset 0) in the route this section applies to. */
    endPointIndex: number;
    /** Section types of the reported route response */
    sectionType: "CAR_TRAIN" | "COUNTRY" | "FERRY" | "MOTORWAY" | "PEDESTRIAN" | "TOLL_ROAD" | "TOLL_VIGNETTE" | "TRAFFIC" | "TRAVEL_MODE" | "TUNNEL" | "CARPOOL" | "URBAN";
    /** Travel mode for the calculated route. The value will be set to `other` if the requested mode of transport is not possible in this section */
    travelMode?: "car" | "truck" | "taxi" | "bus" | "van" | "motorcycle" | "bicycle" | "pedestrian" | "other";
    /** Type of the incident. Can currently be JAM, ROAD_WORK, ROAD_CLOSURE, or OTHER. See "tec" for detailed information. */
    simpleCategory?: "JAM" | "ROAD_WORK" | "ROAD_CLOSURE" | "OTHER";
    /** Effective speed of the incident in km/h, averaged over its entire length. */
    effectiveSpeedInKmh?: number;
    /** Delay in seconds caused by the incident. */
    delayInSeconds?: number;
    /** The magnitude of delay caused by the incident. These values correspond to the values of the response field ty of the [Get Traffic Incident Detail API](https://docs.microsoft.com/rest/api/maps/traffic/gettrafficincidentdetail). */
    magnitudeOfDelay?: "0" | "1" | "2" | "3" | "4";
    /** Details of the traffic event, using definitions in the [TPEG2-TEC](https://www.iso.org/standard/63116.html) standard. Can contain effectCode and causes elements. */
    tec?: RouteSectionTecOutput;
}

/** The cause of the traffic event. Can contain mainCauseCode and subCauseCode elements. Can be used to define iconography and descriptions. */
export declare interface RouteSectionTecCauseOutput {
    /** The main cause of the traffic event. Contains a value in the tec002:CauseCode table, as defined in the [TPEG2-TEC](https://www.iso.org/standard/63116.html) standard. */
    mainCauseCode?: number;
    /** The subcause of the traffic event. Contains a value in the sub cause table defined by the mainCauseCode, as defined in the [TPEG2-TEC](https://www.iso.org/standard/63116.html) standard. */
    subCauseCode?: number;
}

/** Details of the traffic event, using definitions in the [TPEG2-TEC](https://www.iso.org/standard/63116.html) standard. Can contain effectCode and causes elements. */
export declare interface RouteSectionTecOutput {
    /** The effect on the traffic flow. Contains a value in the tec001:EffectCode table, as defined in the [TPEG2-TEC](https://www.iso.org/standard/63116.html) standard. Can be used to color-code traffic events according to severity. */
    effectCode?: number;
    /** Causes array */
    causes?: Array<RouteSectionTecCauseOutput>;
}

/** Summary object */
export declare interface RouteSummaryOutput {
    /** Length In Meters property */
    lengthInMeters: number;
    /** Estimated travel time in seconds property that includes the delay due to real-time traffic. Note that even when traffic=false travelTimeInSeconds still includes the delay due to traffic. If DepartAt is in the future, travel time is calculated using time-dependent historic traffic data. */
    travelTimeInSeconds: number;
    /** Estimated delay in seconds caused by the real-time incident(s) according to traffic information. For routes planned with departure time in the future, delays is always 0. To return additional travel times using different types of traffic information, parameter computeTravelTimeFor=all needs to be added. */
    trafficDelayInSeconds: number;
    /** The estimated departure time for the route or leg. */
    departureTime: string;
    /** The estimated arrival time for the route or leg. */
    arrivalTime: string;
}

/**
 * Transform an array of [Latitude, Longtitute] to a string in the following format:
 * "Latitude_1,Longtitute_1:Latitude_2,Longtitute_2:..."
 *
 * @param coordinates - An array of Latitude/Longtitute pair to transform.
 * @returns The transformed string.
 */
export declare function toColonDelimitedLatLonString(coordinates: LatLon[]): string;

export { }
